import { JsonObject, LsonObject, BaseUserMeta, LiveObject, User, Json, RoomNotificationSettings, Room, Status, BroadcastOptions, OthersEvent, LostConnectionEvent, History, BaseMetadata as BaseMetadata$1, Client as Client$1, ClientOptions } from '@liveblocks/client';
import { BaseMetadata, CommentBody, Patchable, StorageStatus, QueryMetadata, AsyncResult, DRI, AsyncSuccess, CommentAttachment, InboxNotificationData, Resolve, ToImmutable, AsyncLoading, AsyncError, ThreadData, HistoryVersion, Client, LiveblocksError, RoomEventMessage, CommentData, PartialUnless, ThreadDataWithDeleteInfo, OpaqueClient, CommentUserReaction, ThreadDeleteInfo, InboxNotificationDeleteInfo, RoomNotificationSettings as RoomNotificationSettings$1, DistributiveOmit, DU, DM } from '@liveblocks/core';
import React__default, { PropsWithChildren } from 'react';

/**
 * @private Internal API, do not rely on it.
 */
declare class CreateThreadError<M extends BaseMetadata> extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
        metadata: M;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
        metadata: M;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare class EditThreadMetadataError<M extends BaseMetadata> extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        metadata: Patchable<M>;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        metadata: Patchable<M>;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare class CreateCommentError extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare class EditCommentError extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
        body: CommentBody;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare class DeleteCommentError extends Error {
    cause: Error;
    context: {
        roomId: string;
        threadId: string;
        commentId: string;
    };
    constructor(cause: Error, context: {
        roomId: string;
        threadId: string;
        commentId: string;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare class MarkInboxNotificationAsReadError extends Error {
    cause: Error;
    context: {
        inboxNotificationId: string;
    };
    constructor(cause: Error, context: {
        inboxNotificationId: string;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare class UpdateNotificationSettingsError extends Error {
    cause: Error;
    context: {
        roomId: string;
    };
    constructor(cause: Error, context: {
        roomId: string;
    });
}
/**
 * @private Internal API, do not rely on it.
 */
declare type CommentsError<M extends BaseMetadata> = CreateThreadError<M> | EditThreadMetadataError<M> | CreateCommentError | EditCommentError | DeleteCommentError | MarkInboxNotificationAsReadError | UpdateNotificationSettingsError;

declare type UseStorageStatusOptions = {
    /**
     * When setting smooth, the hook will not update immediately as status
     * changes. This is because in typical applications, these states can change
     * quickly between synchronizing and synchronized. If you use this hook to
     * build a "Saving changes..." style UI, prefer setting `smooth: true`.
     */
    smooth?: boolean;
};
declare type StorageStatusSuccess = Exclude<StorageStatus, "not-loaded" | "loading">;
declare type ThreadsQuery<M extends BaseMetadata> = {
    /**
     * Whether to only return threads marked as resolved or unresolved. If not provided,
     * all threads will be returned.
     */
    resolved?: boolean;
    /**
     * The metadata to filter the threads by. If provided, only threads with metadata that matches
     * the provided metadata will be returned. If not provided, all threads will be returned.
     */
    metadata?: Partial<QueryMetadata<M>>;
};
declare type UseUserThreadsOptions<M extends BaseMetadata> = {
    /**
     * The query (including metadata) to filter the threads by. If provided, only threads
     * that match the query will be returned. If not provided, all threads will be returned.
     */
    query?: ThreadsQuery<M>;
};
declare type UseThreadsOptions<M extends BaseMetadata> = {
    /**
     * The query (including metadata) to filter the threads by. If provided, only threads
     * that match the query will be returned. If not provided, all threads will be returned.
     */
    query?: ThreadsQuery<M>;
    /**
     * Whether to scroll to a comment on load based on the URL hash. Defaults to `true`.
     *
     * @example
     * Given the URL `https://example.com/my-room#cm_xxx`, the `cm_xxx` comment will be
     * scrolled to on load if it exists in the page.
     */
    scrollOnLoad?: boolean;
};
declare type UserAsyncResult<T> = AsyncResult<T, "user">;
declare type UserAsyncSuccess<T> = AsyncSuccess<T, "user">;
declare type RoomInfoAsyncResult = AsyncResult<DRI, "info">;
declare type RoomInfoAsyncSuccess = AsyncSuccess<DRI, "info">;
declare type AttachmentUrlAsyncResult = AsyncResult<string, "url">;
declare type AttachmentUrlAsyncSuccess = AsyncSuccess<string, "url">;
declare type CreateThreadOptions<M extends BaseMetadata> = Resolve<{
    body: CommentBody;
    attachments?: CommentAttachment[];
} & PartialUnless<M, {
    metadata: M;
}>>;
declare type EditThreadMetadataOptions<M extends BaseMetadata> = {
    threadId: string;
    metadata: Patchable<M>;
};
declare type CreateCommentOptions = {
    threadId: string;
    body: CommentBody;
    attachments?: CommentAttachment[];
};
declare type EditCommentOptions = {
    threadId: string;
    commentId: string;
    body: CommentBody;
    attachments?: CommentAttachment[];
};
declare type DeleteCommentOptions = {
    threadId: string;
    commentId: string;
};
declare type CommentReactionOptions = {
    threadId: string;
    commentId: string;
    emoji: string;
};
declare type NoPaginationFields = {
    hasFetchedAll?: never;
    isFetchingMore?: never;
    fetchMore?: never;
    fetchMoreError?: never;
};
declare type PaginationFields = {
    hasFetchedAll: boolean;
    isFetchingMore: boolean;
    fetchMore: () => void;
    fetchMoreError?: Error;
};
declare type PagedAsyncSuccess<T, F extends string> = Resolve<AsyncSuccess<T, F> & PaginationFields>;
declare type PagedAsyncResult<T, F extends string> = Resolve<AsyncLoading<F> & NoPaginationFields> | Resolve<AsyncError<F> & NoPaginationFields> | PagedAsyncSuccess<T, F>;
declare type ThreadsAsyncSuccess<M extends BaseMetadata> = PagedAsyncSuccess<ThreadData<M>[], "threads">;
declare type ThreadsAsyncResult<M extends BaseMetadata> = PagedAsyncResult<ThreadData<M>[], "threads">;
declare type InboxNotificationsAsyncSuccess = PagedAsyncSuccess<InboxNotificationData[], "inboxNotifications">;
declare type InboxNotificationsAsyncResult = PagedAsyncResult<InboxNotificationData[], "inboxNotifications">;
declare type UnreadInboxNotificationsCountAsyncSuccess = AsyncSuccess<number, "count">;
declare type UnreadInboxNotificationsCountAsyncResult = AsyncResult<number, "count">;
declare type RoomNotificationSettingsAsyncSuccess = AsyncSuccess<RoomNotificationSettings, "settings">;
declare type RoomNotificationSettingsAsyncResult = AsyncResult<RoomNotificationSettings, "settings">;
declare type HistoryVersionDataAsyncResult = AsyncResult<Uint8Array>;
declare type HistoryVersionsAsyncSuccess = AsyncSuccess<HistoryVersion[], "versions">;
declare type HistoryVersionsAsyncResult = AsyncResult<HistoryVersion[], "versions">;
declare type RoomProviderProps<P extends JsonObject, S extends LsonObject> = Resolve<{
    /**
     * The id of the room you want to connect to
     */
    id: string;
    children: React.ReactNode;
    /**
     * Whether or not the room should connect to Liveblocks servers
     * when the RoomProvider is rendered.
     *
     * By default equals to `typeof window !== "undefined"`,
     * meaning the RoomProvider tries to connect to Liveblocks servers
     * only on the client side.
     */
    autoConnect?: boolean;
    /**
     * If you're on React 17 or lower, pass in a reference to
     * `ReactDOM.unstable_batchedUpdates` or
     * `ReactNative.unstable_batchedUpdates` here.
     *
     * @example
     * import { unstable_batchedUpdates } from "react-dom";
     *
     * <RoomProvider ... unstable_batchedUpdates={unstable_batchedUpdates} />
     *
     * This will prevent you from running into the so-called "stale props"
     * and/or "zombie child" problem that React 17 and lower can suffer from.
     * Not necessary when you're on React v18 or later.
     */
    unstable_batchedUpdates?: (cb: () => void) => void;
} & PartialUnless<P, {
    /**
     * The initial Presence to use and announce when you enter the Room. The
     * Presence is available on all users in the Room (me & others).
     */
    initialPresence: P | ((roomId: string) => P);
}> & PartialUnless<S, {
    /**
     * The initial Storage to use when entering a new Room.
     */
    initialStorage: S | ((roomId: string) => S);
}>>;
/**
 * For any function type, returns a similar function type, but without the
 * first argument.
 */
declare type OmitFirstArg<F> = F extends (first: any, ...rest: infer A) => infer R ? (...args: A) => R : never;
declare type MutationContext<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta> = {
    storage: LiveObject<S>;
    self: User<P, U>;
    others: readonly User<P, U>[];
    setMyPresence: (patch: Partial<P>, options?: {
        addToHistory: boolean;
    }) => void;
};
declare type ThreadSubscription = {
    status: "not-subscribed";
    unreadSince?: never;
} | {
    status: "subscribed";
    unreadSince: null;
} | {
    status: "subscribed";
    unreadSince: Date;
};
declare type SharedContextBundle<U extends BaseUserMeta> = {
    classic: {
        /**
         * Obtains a reference to the current Liveblocks client.
         */
        useClient(): Client<U>;
        /**
         * Returns user info from a given user ID.
         *
         * @example
         * const { user, error, isLoading } = useUser("user-id");
         */
        useUser(userId: string): UserAsyncResult<U["info"]>;
        /**
         * Returns room info from a given room ID.
         *
         * @example
         * const { info, error, isLoading } = useRoomInfo("room-id");
         */
        useRoomInfo(roomId: string): RoomInfoAsyncResult;
        /**
         * Returns whether the hook is called within a RoomProvider context.
         *
         * @example
         * const isInsideRoom = useIsInsideRoom();
         */
        useIsInsideRoom(): boolean;
    };
    suspense: {
        /**
         * Obtains a reference to the current Liveblocks client.
         */
        useClient(): Client<U>;
        /**
         * Returns user info from a given user ID.
         *
         * @example
         * const { user } = useUser("user-id");
         */
        useUser(userId: string): UserAsyncSuccess<U["info"]>;
        /**
         * Returns room info from a given room ID.
         *
         * @example
         * const { info } = useRoomInfo("room-id");
         */
        useRoomInfo(roomId: string): RoomInfoAsyncSuccess;
        /**
         * Returns whether the hook is called within a RoomProvider context.
         *
         * @example
         * const isInsideRoom = useIsInsideRoom();
         */
        useIsInsideRoom(): boolean;
    };
};
/**
 * Properties that are the same in RoomContext and RoomContext["suspense"].
 */
declare type RoomContextBundleCommon<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta, E extends Json, M extends BaseMetadata> = {
    /**
     * You normally don't need to directly interact with the RoomContext, but
     * it can be necessary if you're building an advanced app where you need to
     * set up a context bridge between two React renderers.
     */
    RoomContext: React.Context<Room<P, S, U, E, M> | null>;
    /**
     * Makes a Room available in the component hierarchy below.
     * Joins the room when the component is mounted, and automatically leaves
     * the room when the component is unmounted.
     */
    RoomProvider(props: RoomProviderProps<P, S>): JSX.Element;
    /**
     * Returns the Room of the nearest RoomProvider above in the React component
     * tree.
     */
    useRoom(): Room<P, S, U, E, M>;
    /**
     * Returns the current connection status for the Room, and triggers
     * a re-render whenever it changes. Can be used to render a status badge.
     */
    useStatus(): Status;
    /**
     * @deprecated It's recommended to use `useMutation` for writing to Storage,
     * which will automatically batch all mutations.
     *
     * Returns a function that batches modifications made during the given function.
     * All the modifications are sent to other clients in a single message.
     * All the modifications are merged in a single history item (undo/redo).
     * All the subscribers are called only after the batch is over.
     */
    useBatch<T>(): (callback: () => T) => T;
    /**
     * Returns a callback that lets you broadcast custom events to other users in the room
     *
     * @example
     * const broadcast = useBroadcastEvent();
     *
     * broadcast({ type: "CUSTOM_EVENT", data: { x: 0, y: 0 } });
     */
    useBroadcastEvent(): (event: E, options?: BroadcastOptions) => void;
    /**
     * Get informed when users enter or leave the room, as an event.
     *
     * @example
     * useOthersListener({ type, user, others }) => {
     *   if (type === 'enter') {
     *     // `user` has joined the room
     *   } else if (type === 'leave') {
     *     // `user` has left the room
     *   }
     * })
     */
    useOthersListener(callback: (event: OthersEvent<P, U>) => void): void;
    /**
     * Get informed when reconnecting to the Liveblocks servers is taking
     * longer than usual. This typically is a sign of a client that has lost
     * internet connectivity.
     *
     * This isn't problematic (because the Liveblocks client is still trying to
     * reconnect), but it's typically a good idea to inform users about it if
     * the connection takes too long to recover.
     *
     * @example
     * useLostConnectionListener(event => {
     *   if (event === 'lost') {
     *     toast.warn('Reconnecting to the Liveblocks servers is taking longer than usual...')
     *   } else if (event === 'failed') {
     *     toast.warn('Reconnecting to the Liveblocks servers failed.')
     *   } else if (event === 'restored') {
     *     toast.clear();
     *   }
     * })
     */
    useLostConnectionListener(callback: (event: LostConnectionEvent) => void): void;
    /**
     * useErrorListener is a React hook that allows you to respond to potential room
     * connection errors.
     *
     * @example
     * useErrorListener(er => {
     *   console.error(er);
     * })
     */
    useErrorListener(callback: (err: LiveblocksError) => void): void;
    /**
     * useEventListener is a React hook that allows you to respond to events broadcast
     * by other users in the room.
     *
     * The `user` argument will indicate which `User` instance sent the message.
     * This will be equal to one of the others in the room, but it can be `null`
     * in case this event was broadcasted from the server.
     *
     * @example
     * useEventListener(({ event, user, connectionId }) => {
     * //                         ^^^^ Will be Client A
     *   if (event.type === "CUSTOM_EVENT") {
     *     // Do something
     *   }
     * });
     */
    useEventListener(callback: (data: RoomEventMessage<P, U, E>) => void): void;
    /**
     * Returns the room.history
     */
    useHistory(): History;
    /**
     * Returns a function that undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    useUndo(): () => void;
    /**
     * Returns a function that redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    useRedo(): () => void;
    /**
     * Returns whether there are any operations to undo.
     */
    useCanUndo(): boolean;
    /**
     * Returns whether there are any operations to redo.
     */
    useCanRedo(): boolean;
    /**
     * Returns the mutable (!) Storage root. This hook exists for
     * backward-compatible reasons.
     *
     * @example
     * const [root] = useStorageRoot();
     */
    useStorageRoot(): [root: LiveObject<S> | null];
    /**
     * Returns the presence of the current user of the current room, and a function to update it.
     * It is different from the setState function returned by the useState hook from React.
     * You don't need to pass the full presence object to update it.
     *
     * @example
     * const [myPresence, updateMyPresence] = useMyPresence();
     * updateMyPresence({ x: 0 });
     * updateMyPresence({ y: 0 });
     *
     * // At the next render, "myPresence" will be equal to "{ x: 0, y: 0 }"
     */
    useMyPresence(): [
        P,
        (patch: Partial<P>, options?: {
            addToHistory: boolean;
        }) => void
    ];
    /**
     * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.
     * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.
     *
     * @example
     * const updateMyPresence = useUpdateMyPresence();
     * updateMyPresence({ x: 0 });
     * updateMyPresence({ y: 0 });
     *
     * // At the next render, the presence of the current user will be equal to "{ x: 0, y: 0 }"
     */
    useUpdateMyPresence(): (patch: Partial<P>, options?: {
        addToHistory: boolean;
    }) => void;
    /**
     * Create a callback function that lets you mutate Liveblocks state.
     *
     * The first argument that gets passed into your callback will be
     * a "mutation context", which exposes the following:
     *
     *   - `storage` - The mutable Storage root.
     *                 You can mutate any Live structures with this, for example:
     *                 `storage.get('layers').get('layer1').set('fill', 'red')`
     *
     *   - `setMyPresence` - Call this with a new (partial) Presence value.
     *
     *   - `self` - A read-only version of the latest self, if you need it to
     *              compute the next state.
     *
     *   - `others` - A read-only version of the latest others list, if you
     *                need it to compute the next state.
     *
     * useMutation is like React's useCallback, except that the first argument
     * that gets passed into your callback will be a "mutation context".
     *
     * If you want get access to the immutable root somewhere in your mutation,
     * you can use `storage.ToImmutable()`.
     *
     * @example
     * const fillLayers = useMutation(
     *   ({ storage }, color: Color) => {
     *     ...
     *   },
     *   [],
     * );
     *
     * fillLayers('red');
     *
     * const deleteLayers = useMutation(
     *   ({ storage }) => {
     *     ...
     *   },
     *   [],
     * );
     *
     * deleteLayers();
     */
    useMutation<F extends (context: MutationContext<P, S, U>, ...args: any[]) => any>(callback: F, deps: readonly unknown[]): OmitFirstArg<F>;
    /**
     * Returns an array with information about all the users currently connected
     * in the room (except yourself).
     *
     * @example
     * const others = useOthers();
     *
     * // Example to map all cursors in JSX
     * return (
     *   <>
     *     {others.map((user) => {
     *        if (user.presence.cursor == null) {
     *          return null;
     *        }
     *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />
     *      })}
     *   </>
     * )
     */
    useOthers(): readonly User<P, U>[];
    /**
     * Extract arbitrary data based on all the users currently connected in the
     * room (except yourself).
     *
     * The selector function will get re-evaluated any time a user enters or
     * leaves the room, as well as whenever their presence data changes.
     *
     * The component that uses this hook will automatically re-render if your
     * selector function returns a different value from its previous run.
     *
     * By default `useOthers()` uses strict `===` to check for equality. Take
     * extra care when returning a computed object or list, for example when you
     * return the result of a .map() or .filter() call from the selector. In
     * those cases, you'll probably want to use a `shallow` comparison check.
     *
     * @example
     * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);
     * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);
     * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));
     *
     */
    useOthers<T>(selector: (others: readonly User<P, U>[]) => T, isEqual?: (prev: T, curr: T) => boolean): T;
    /**
     * Returns an array of connection IDs. This matches the values you'll get by
     * using the `useOthers()` hook.
     *
     * Roughly equivalent to:
     *   useOthers((others) => others.map(other => other.connectionId), shallow)
     *
     * This is useful in particular to implement efficiently rendering components
     * for each user in the room, e.g. cursors.
     *
     * @example
     * const ids = useOthersConnectionIds();
     * // [2, 4, 7]
     */
    useOthersConnectionIds(): readonly number[];
    /**
     * Related to useOthers(), but optimized for selecting only "subsets" of
     * others. This is useful for performance reasons in particular, because
     * selecting only a subset of users also means limiting the number of
     * re-renders that will be triggered.
     *
     * @example
     * const avatars = useOthersMapped(user => user.info.avatar);
     * //    ^^^^^^^
     * //    { connectionId: number; data: string }[]
     *
     * The selector function you pass to useOthersMapped() is called an "item
     * selector", and operates on a single user at a time. If you provide an
     * (optional) "item comparison" function, it will be used to compare each
     * item pairwise.
     *
     * For example, to select multiple properties:
     *
     * @example
     * const avatarsAndCursors = useOthersMapped(
     *   user => [u.info.avatar, u.presence.cursor],
     *   shallow,  // ðŸ‘ˆ
     * );
     */
    useOthersMapped<T>(itemSelector: (other: User<P, U>) => T, itemIsEqual?: (prev: T, curr: T) => boolean): ReadonlyArray<readonly [connectionId: number, data: T]>;
    /**
     * Given a connection ID (as obtained by using `useOthersConnectionIds`), you
     * can call this selector deep down in your component stack to only have the
     * component re-render if properties for this particular user change.
     *
     * @example
     * // Returns only the selected values re-renders whenever that selection changes)
     * const { x, y } = useOther(2, user => user.presence.cursor);
     */
    useOther<T>(connectionId: number, selector: (other: User<P, U>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
    /**
     * Returns a function that creates a thread with an initial comment, and optionally some metadata.
     *
     * @example
     * const createThread = useCreateThread();
     * createThread({ body: {}, metadata: {} });
     */
    useCreateThread(): (options: CreateThreadOptions<M>) => ThreadData<M>;
    /**
     * Returns a function that deletes a thread and its associated comments.
     * Only the thread creator can delete a thread, it will throw otherwise.
     *
     * @example
     * const deleteThread = useDeleteThread();
     * deleteThread("th_xxx");
     */
    useDeleteThread(): (threadId: string) => void;
    /**
     * Returns a function that edits a thread's metadata.
     * To delete an existing metadata property, set its value to `null`.
     *
     * @example
     * const editThreadMetadata = useEditThreadMetadata();
     * editThreadMetadata({ threadId: "th_xxx", metadata: {} })
     */
    useEditThreadMetadata(): (options: EditThreadMetadataOptions<M>) => void;
    /**
     * Returns a function that marks a thread as resolved.
     *
     * @example
     * const markThreadAsResolved = useMarkThreadAsResolved();
     * markThreadAsResolved("th_xxx");
     */
    useMarkThreadAsResolved(): (threadId: string) => void;
    /**
     * Returns a function that marks a thread as unresolved.
     *
     * @example
     * const markThreadAsUnresolved = useMarkThreadAsUnresolved();
     * markThreadAsUnresolved("th_xxx");
     */
    useMarkThreadAsUnresolved(): (threadId: string) => void;
    /**
     * Returns a function that adds a comment to a thread.
     *
     * @example
     * const createComment = useCreateComment();
     * createComment({ threadId: "th_xxx", body: {} });
     */
    useCreateComment(): (options: CreateCommentOptions) => CommentData;
    /**
     * Returns a function that edits a comment's body.
     *
     * @example
     * const editComment = useEditComment()
     * editComment({ threadId: "th_xxx", commentId: "cm_xxx", body: {} })
     */
    useEditComment(): (options: EditCommentOptions) => void;
    /**
     * Returns a function that deletes a comment.
     * If it is the last non-deleted comment, the thread also gets deleted.
     *
     * @example
     * const deleteComment = useDeleteComment();
     * deleteComment({ threadId: "th_xxx", commentId: "cm_xxx" })
     */
    useDeleteComment(): (options: DeleteCommentOptions) => void;
    /**
     * Returns a function that adds a reaction from a comment.
     *
     * @example
     * const addReaction = useAddReaction();
     * addReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "ðŸ‘" })
     */
    useAddReaction(): (options: CommentReactionOptions) => void;
    /**
     * Returns a function that removes a reaction on a comment.
     *
     * @example
     * const removeReaction = useRemoveReaction();
     * removeReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "ðŸ‘" })
     */
    useRemoveReaction(): (options: CommentReactionOptions) => void;
    /**
     * Returns a function that updates the user's notification settings
     * for the current room.
     *
     * @example
     * const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
     * updateRoomNotificationSettings({ threads: "all" });
     */
    useUpdateRoomNotificationSettings(): (settings: Partial<RoomNotificationSettings>) => void;
    /**
     * Returns a function that marks a thread as read.
     *
     * @example
     * const markThreadAsRead = useMarkThreadAsRead();
     * markThreadAsRead("th_xxx");
     */
    useMarkThreadAsRead(): (threadId: string) => void;
    /**
     * Returns the subscription status of a thread.
     *
     * @example
     * const { status, unreadSince } = useThreadSubscription("th_xxx");
     */
    useThreadSubscription(threadId: string): ThreadSubscription;
};
/**
 * @private
 *
 * Private methods and variables used in the core internals, but as a user
 * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things
 * will probably happen if you do.
 */
declare type PrivateRoomContextApi = {
    useCommentsErrorListener<M extends BaseMetadata>(callback: (err: CommentsError<M>) => void): void;
};
declare type RoomContextBundle<P extends JsonObject, S extends LsonObject, U extends BaseUserMeta, E extends Json, M extends BaseMetadata> = Resolve<RoomContextBundleCommon<P, S, U, E, M> & SharedContextBundle<U>["classic"] & {
    /**
     * Returns the current storage status for the Room, and triggers
     * a re-render whenever it changes. Can be used to render a "Saving..."
     * indicator.
     */
    useStorageStatus(options?: UseStorageStatusOptions): StorageStatus;
    /**
     * Extract arbitrary data from the Liveblocks Storage state, using an
     * arbitrary selector function.
     *
     * The selector function will get re-evaluated any time something changes in
     * Storage. The value returned by your selector function will also be the
     * value returned by the hook.
     *
     * The `root` value that gets passed to your selector function is
     * a immutable/readonly version of your Liveblocks storage root.
     *
     * The component that uses this hook will automatically re-render if the
     * returned value changes.
     *
     * By default `useStorage()` uses strict `===` to check for equality. Take
     * extra care when returning a computed object or list, for example when you
     * return the result of a .map() or .filter() call from the selector. In
     * those cases, you'll probably want to use a `shallow` comparison check.
     */
    useStorage<T>(selector: (root: ToImmutable<S>) => T, isEqual?: (prev: T | null, curr: T | null) => boolean): T | null;
    /**
     * Gets the current user once it is connected to the room.
     *
     * @example
     * const me = useSelf();
     * if (me !== null) {
     *   const { x, y } = me.presence.cursor;
     * }
     */
    useSelf(): User<P, U> | null;
    /**
     * Extract arbitrary data based on the current user.
     *
     * The selector function will get re-evaluated any time your presence data
     * changes.
     *
     * The component that uses this hook will automatically re-render if your
     * selector function returns a different value from its previous run.
     *
     * By default `useSelf()` uses strict `===` to check for equality. Take extra
     * care when returning a computed object or list, for example when you return
     * the result of a .map() or .filter() call from the selector. In those
     * cases, you'll probably want to use a `shallow` comparison check.
     *
     * Will return `null` while Liveblocks isn't connected to a room yet.
     *
     * @example
     * const cursor = useSelf(me => me.presence.cursor);
     * if (cursor !== null) {
     *   const { x, y } = cursor;
     * }
     *
     */
    useSelf<T>(selector: (me: User<P, U>) => T, isEqual?: (prev: T, curr: T) => boolean): T | null;
    /**
     * Returns the threads within the current room.
     *
     * @example
     * const { threads, error, isLoading } = useThreads();
     */
    useThreads(options?: UseThreadsOptions<M>): ThreadsAsyncResult<M>;
    /**
     * Returns the user's notification settings for the current room
     * and a function to update them.
     *
     * @example
     * const [{ settings }, updateSettings] = useRoomNotificationSettings();
     */
    useRoomNotificationSettings(): [
        RoomNotificationSettingsAsyncResult,
        (settings: Partial<RoomNotificationSettings>) => void
    ];
    /**
     * Returns a presigned URL for an attachment by its ID.
     *
     * @example
     * const { url, error, isLoading } = useAttachmentUrl("at_xxx");
     */
    useAttachmentUrl(attachmentId: string): AttachmentUrlAsyncResult;
    /**
     * (Private beta)  Returns a history of versions of the current room.
     *
     * @example
     * const { versions, error, isLoading } = useHistoryVersions();
     */
    useHistoryVersions(): HistoryVersionsAsyncResult;
    /**
     * (Private beta) Returns the data of a specific version of the current room.
     *
     * @example
     * const { data, error, isLoading } = useHistoryVersionData(version.id);
     */
    useHistoryVersionData(id: string): HistoryVersionDataAsyncResult;
    suspense: Resolve<RoomContextBundleCommon<P, S, U, E, M> & SharedContextBundle<U>["suspense"] & {
        /**
         * Returns the current storage status for the Room, and triggers
         * a re-render whenever it changes. Can be used to render a "Saving..."
         * indicator.
         */
        useStorageStatus(options?: UseStorageStatusOptions): StorageStatusSuccess;
        /**
         * Extract arbitrary data from the Liveblocks Storage state, using an
         * arbitrary selector function.
         *
         * The selector function will get re-evaluated any time something changes in
         * Storage. The value returned by your selector function will also be the
         * value returned by the hook.
         *
         * The `root` value that gets passed to your selector function is
         * a immutable/readonly version of your Liveblocks storage root.
         *
         * The component that uses this hook will automatically re-render if the
         * returned value changes.
         *
         * By default `useStorage()` uses strict `===` to check for equality. Take
         * extra care when returning a computed object or list, for example when you
         * return the result of a .map() or .filter() call from the selector. In
         * those cases, you'll probably want to use a `shallow` comparison check.
         */
        useStorage<T>(selector: (root: ToImmutable<S>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
        /**
         * Gets the current user once it is connected to the room.
         *
         * @example
         * const me = useSelf();
         * const { x, y } = me.presence.cursor;
         */
        useSelf(): User<P, U>;
        /**
         * Extract arbitrary data based on the current user.
         *
         * The selector function will get re-evaluated any time your presence data
         * changes.
         *
         * The component that uses this hook will automatically re-render if your
         * selector function returns a different value from its previous run.
         *
         * By default `useSelf()` uses strict `===` to check for equality. Take extra
         * care when returning a computed object or list, for example when you return
         * the result of a .map() or .filter() call from the selector. In those
         * cases, you'll probably want to use a `shallow` comparison check.
         *
         * @example
         * const cursor = useSelf(me => me.presence.cursor);
         * const { x, y } = cursor;
         *
         */
        useSelf<T>(selector: (me: User<P, U>) => T, isEqual?: (prev: T, curr: T) => boolean): T;
        /**
         * Returns the threads within the current room.
         *
         * @example
         * const { threads } = useThreads();
         */
        useThreads(options?: UseThreadsOptions<M>): ThreadsAsyncSuccess<M>;
        /**
         * (Private beta) Returns a history of versions of the current room.
         *
         * @example
         * const { versions } = useHistoryVersions();
         */
        useHistoryVersions(): HistoryVersionsAsyncSuccess;
        /**
         * Returns the user's notification settings for the current room
         * and a function to update them.
         *
         * @example
         * const [{ settings }, updateSettings] = useRoomNotificationSettings();
         */
        useRoomNotificationSettings(): [
            RoomNotificationSettingsAsyncSuccess,
            (settings: Partial<RoomNotificationSettings>) => void
        ];
        /**
         * Returns a presigned URL for an attachment by its ID.
         *
         * @example
         * const { url } = useAttachmentUrl("at_xxx");
         */
        useAttachmentUrl(attachmentId: string): AttachmentUrlAsyncSuccess;
    }>;
} & PrivateRoomContextApi>;
/**
 * Properties that are the same in LiveblocksContext and LiveblocksContext["suspense"].
 */
declare type LiveblocksContextBundleCommon<M extends BaseMetadata> = {
    /**
     * Makes Liveblocks features outside of rooms (e.g. Notifications) available
     * in the component hierarchy below.
     */
    LiveblocksProvider(props: PropsWithChildren): JSX.Element;
    /**
     * Returns a function that marks an inbox notification as read for the current user.
     *
     * @example
     * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
     * markInboxNotificationAsRead("in_xxx");
     */
    useMarkInboxNotificationAsRead(): (inboxNotificationId: string) => void;
    /**
     * Returns a function that marks all of the current user's inbox notifications as read.
     *
     * @example
     * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();
     * markAllInboxNotificationsAsRead();
     */
    useMarkAllInboxNotificationsAsRead(): () => void;
    /**
     * Returns a function that deletes an inbox notification for the current user.
     *
     * @example
     * const deleteInboxNotification = useDeleteInboxNotification();
     * deleteInboxNotification("in_xxx");
     */
    useDeleteInboxNotification(): (inboxNotificationId: string) => void;
    /**
     * Returns a function that deletes all of the current user's inbox notifications.
     *
     * @example
     * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();
     * deleteAllInboxNotifications();
     */
    useDeleteAllInboxNotifications(): () => void;
    /**
     * Returns the thread associated with a `"thread"` inbox notification.
     *
     * It can **only** be called with IDs of `"thread"` inbox notifications,
     * so we recommend only using it when customizing the rendering or in other
     * situations where you can guarantee the kind of the notification.
     *
     * When `useInboxNotifications` returns `"thread"` inbox notifications,
     * it also receives the associated threads and caches them behind the scenes.
     * When you call `useInboxNotificationThread`, it simply returns the cached thread
     * for the inbox notification ID you passed to it, without any fetching or waterfalls.
     *
     * @example
     * const thread = useInboxNotificationThread("in_xxx");
     */
    useInboxNotificationThread(inboxNotificationId: string): ThreadData<M>;
};
declare type LiveblocksContextBundle<U extends BaseUserMeta, M extends BaseMetadata> = Resolve<LiveblocksContextBundleCommon<M> & SharedContextBundle<U>["classic"] & {
    /**
     * Returns the inbox notifications for the current user.
     *
     * @example
     * const { inboxNotifications, error, isLoading } = useInboxNotifications();
     */
    useInboxNotifications(): InboxNotificationsAsyncResult;
    /**
     * Returns the number of unread inbox notifications for the current user.
     *
     * @example
     * const { count, error, isLoading } = useUnreadInboxNotificationsCount();
     */
    useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountAsyncResult;
    /**
     * @experimental
     *
     * This hook is experimental and could be removed or changed at any time!
     * Do not use unless explicitly recommended by the Liveblocks team.
     */
    useUserThreads_experimental(options?: UseUserThreadsOptions<M>): ThreadsAsyncResult<M>;
    suspense: Resolve<LiveblocksContextBundleCommon<M> & SharedContextBundle<U>["suspense"] & {
        /**
         * Returns the inbox notifications for the current user.
         *
         * @example
         * const { inboxNotifications } = useInboxNotifications();
         */
        useInboxNotifications(): InboxNotificationsAsyncSuccess;
        /**
         * Returns the number of unread inbox notifications for the current user.
         *
         * @example
         * const { count } = useUnreadInboxNotificationsCount();
         */
        useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountAsyncSuccess;
        /**
         * @experimental
         *
         * This hook is experimental and could be removed or changed at any time!
         * Do not use unless explicitly recommended by the Liveblocks team.
         */
        useUserThreads_experimental(options?: UseUserThreadsOptions<M>): ThreadsAsyncSuccess<M>;
    }>;
}>;

declare type ReadonlyThreadDB<M extends BaseMetadata> = Omit<ThreadDB<M>, "upsert" | "delete">;
/**
 * This class implements a lightweight, in-memory, "database" for all Thread
 * instances.
 *
 * It exposes the following methods:
 *
 * - upsert: To add/update a thread
 * - upsertIfNewer: To add/update a thread. Only update an existing thread if
 *                  its newer
 * - delete: To mark existing threads as deleted
 * - get: To get any non-deleted thread
 * - getEvenIfDeleted: To get a thread which is possibly deleted
 * - findMany: To filter an ordered list of non-deleted threads
 * - clone: To clone the DB to mutate it further. This is used to mix in
 *          optimistic updates without losing the original thread contents.
 *
 */
declare class ThreadDB<M extends BaseMetadata> {
    private _byId;
    private _asc;
    private _desc;
    private _version;
    constructor();
    clone(): ThreadDB<M>;
    /** Gets the transaction count for this DB. Increments any time the DB is modified. */
    get version(): number;
    /** Returns an existing thread by ID. Will never return a deleted thread. */
    get(threadId: string): ThreadData<M> | undefined;
    /** Returns the (possibly deleted) thread by ID. */
    getEvenIfDeleted(threadId: string): ThreadDataWithDeleteInfo<M> | undefined;
    /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */
    upsert(thread: ThreadDataWithDeleteInfo<M>): void;
    /** Like .upsert(), except it won't update if a thread by this ID already exists. */
    upsertIfNewer(thread: ThreadDataWithDeleteInfo<M>): void;
    /**
     * Marks a thread as deleted. It will no longer pop up in .findMany()
     * queries, but it can still be accessed via `.getEvenIfDeleted()`.
     */
    delete(threadId: string, deletedAt: Date): void;
    /**
     * Returns all threads matching a given roomId and query. If roomId is not
     * specified, it will return all threads matching the query, across all
     * rooms.
     *
     * Returns the results in the requested order. Please note:
     *   'asc'  means by createdAt ASC
     *   'desc' means by updatedAt DESC
     *
     * Will never return deleted threads in the result.
     */
    findMany(roomId: string | undefined, query: ThreadsQuery<M>, direction: "asc" | "desc"): ThreadData<M>[];
    private touch;
}

declare type OptimisticUpdate<M extends BaseMetadata> = CreateThreadOptimisticUpdate<M> | DeleteThreadOptimisticUpdate | EditThreadMetadataOptimisticUpdate<M> | MarkThreadAsResolvedOptimisticUpdate | MarkThreadAsUnresolvedOptimisticUpdate | CreateCommentOptimisticUpdate | EditCommentOptimisticUpdate | DeleteCommentOptimisticUpdate | AddReactionOptimisticUpdate | RemoveReactionOptimisticUpdate | MarkInboxNotificationAsReadOptimisticUpdate | MarkAllInboxNotificationsAsReadOptimisticUpdate | DeleteInboxNotificationOptimisticUpdate | DeleteAllInboxNotificationsOptimisticUpdate | UpdateNotificationSettingsOptimisticUpdate;
declare type CreateThreadOptimisticUpdate<M extends BaseMetadata> = {
    type: "create-thread";
    id: string;
    roomId: string;
    thread: ThreadData<M>;
};
declare type DeleteThreadOptimisticUpdate = {
    type: "delete-thread";
    id: string;
    roomId: string;
    threadId: string;
    deletedAt: Date;
};
declare type EditThreadMetadataOptimisticUpdate<M extends BaseMetadata> = {
    type: "edit-thread-metadata";
    id: string;
    threadId: string;
    metadata: Resolve<Patchable<M>>;
    updatedAt: Date;
};
declare type MarkThreadAsResolvedOptimisticUpdate = {
    type: "mark-thread-as-resolved";
    id: string;
    threadId: string;
    updatedAt: Date;
};
declare type MarkThreadAsUnresolvedOptimisticUpdate = {
    type: "mark-thread-as-unresolved";
    id: string;
    threadId: string;
    updatedAt: Date;
};
declare type CreateCommentOptimisticUpdate = {
    type: "create-comment";
    id: string;
    comment: CommentData;
};
declare type EditCommentOptimisticUpdate = {
    type: "edit-comment";
    id: string;
    comment: CommentData;
};
declare type DeleteCommentOptimisticUpdate = {
    type: "delete-comment";
    id: string;
    roomId: string;
    threadId: string;
    deletedAt: Date;
    commentId: string;
};
declare type AddReactionOptimisticUpdate = {
    type: "add-reaction";
    id: string;
    threadId: string;
    commentId: string;
    reaction: CommentUserReaction;
};
declare type RemoveReactionOptimisticUpdate = {
    type: "remove-reaction";
    id: string;
    threadId: string;
    commentId: string;
    emoji: string;
    userId: string;
    removedAt: Date;
};
declare type MarkInboxNotificationAsReadOptimisticUpdate = {
    type: "mark-inbox-notification-as-read";
    id: string;
    inboxNotificationId: string;
    readAt: Date;
};
declare type MarkAllInboxNotificationsAsReadOptimisticUpdate = {
    type: "mark-all-inbox-notifications-as-read";
    id: string;
    readAt: Date;
};
declare type DeleteInboxNotificationOptimisticUpdate = {
    type: "delete-inbox-notification";
    id: string;
    inboxNotificationId: string;
    deletedAt: Date;
};
declare type DeleteAllInboxNotificationsOptimisticUpdate = {
    type: "delete-all-inbox-notifications";
    id: string;
    deletedAt: Date;
};
declare type UpdateNotificationSettingsOptimisticUpdate = {
    type: "update-notification-settings";
    id: string;
    roomId: string;
    settings: Partial<RoomNotificationSettings$1>;
};
/**
 * Like Promise<T>, except it will have a synchronously readable `status`
 * field, indicating the status of the promise.
 * This is compatible with React's `use()` promises, hence the name.
 */
declare type UsablePromise<T> = Promise<T> & ({
    status: "pending";
} | {
    status: "rejected";
    reason: Error;
} | {
    status: "fulfilled";
    value: T;
});
/**
 * Externally observable state of the store, which will have:
 * - Optimistic updates applied
 * - All deleted threads removed from the threads list
 */
declare type UmbrellaStoreState<M extends BaseMetadata> = {
    /**
     * Keep track of loading and error status of all the queries made by the client.
     * e.g. 'room-abc-{"color":"red"}'  - ok
     * e.g. 'room-abc-{}'               - loading
     */
    threadsDB: ReadonlyThreadDB<M>;
    /**
     * All inbox notifications in a sorted array, optimistic updates applied.
     */
    cleanedNotifications: InboxNotificationData[];
    /**
     * Inbox notifications by ID.
     * e.g. `in_${string}`
     */
    notificationsById: Record<string, InboxNotificationData>;
    /**
     * Notification settings by room ID.
     * e.g. { 'room-abc': { threads: "all" },
     *        'room-def': { threads: "replies_and_mentions" },
     *        'room-xyz': { threads: "none" },
     *      }
     */
    settingsByRoomId: Record<string, RoomNotificationSettings$1>;
    /**
     * Versions by roomId
     * e.g. { 'room-abc': {versions: "all versions"}}
     */
    versionsByRoomId: Record<string, Record<string, HistoryVersion>>;
};
declare class UmbrellaStore<M extends BaseMetadata> {
    private _client;
    private _rawThreadsDB;
    private _prevVersion;
    private _store;
    private _prevState;
    private _stateCached;
    private _notificationsLastRequestedAt;
    private _notifications;
    private _roomThreadsLastRequestedAtByRoom;
    private _roomThreads;
    private _userThreadsLastRequestedAt;
    private _userThreads;
    private _roomVersions;
    private _roomVersionsLastRequestedAtByRoom;
    private _roomNotificationSettings;
    constructor(client: OpaqueClient);
    private get;
    batch(callback: () => void): void;
    getFullState(): UmbrellaStoreState<M>;
    /**
     * Returns the async result of the given query and room id. If the query is success,
     * then it will return the threads that match that provided query and room id.
     *
     */
    getRoomThreadsLoadingState(roomId: string, query: ThreadsQuery<M> | undefined): ThreadsAsyncResult<M>;
    getUserThreadsLoadingState(query: ThreadsQuery<M> | undefined): ThreadsAsyncResult<M>;
    getInboxNotificationsLoadingState(): InboxNotificationsAsyncResult;
    getNotificationSettingsLoadingState(roomId: string): RoomNotificationSettingsAsyncResult;
    getRoomVersionsLoadingState(roomId: string): AsyncResult<HistoryVersion[], "versions">;
    /**
     * @private Only used by the E2E test suite.
     */
    _hasOptimisticUpdates(): boolean;
    subscribe(callback: () => void): () => void;
    private mutateThreadsDB;
    private updateInboxNotificationsCache;
    private setNotificationSettings;
    private updateRoomVersions;
    private updateOptimisticUpdatesCache;
    /**
     * Updates an existing inbox notification with a new value, replacing the
     * corresponding optimistic update.
     *
     * This will not update anything if the inbox notification ID isn't found in
     * the cache.
     */
    updateInboxNotification(inboxNotificationId: string, optimisticUpdateId: string, callback: (notification: Readonly<InboxNotificationData>) => Readonly<InboxNotificationData>): void;
    /**
     * Updates *all* inbox notifications by running a mapper function over all of
     * them, replacing the corresponding optimistic update.
     */
    updateAllInboxNotifications(optimisticUpdateId: string, mapFn: (notification: Readonly<InboxNotificationData>) => Readonly<InboxNotificationData>): void;
    /**
     * Deletes an existing inbox notification, replacing the corresponding
     * optimistic update.
     */
    deleteInboxNotification(inboxNotificationId: string, optimisticUpdateId: string): void;
    /**
     * Deletes *all* inbox notifications, replacing the corresponding optimistic
     * update.
     */
    deleteAllInboxNotifications(optimisticUpdateId: string): void;
    /**
     * Creates an new thread, replacing the corresponding optimistic update.
     */
    createThread(optimisticUpdateId: string, thread: Readonly<ThreadDataWithDeleteInfo<M>>): void;
    /**
     * Updates an existing thread with a new value, replacing the corresponding
     * optimistic update.
     *
     * This will not update anything if:
     * - The thread ID isn't found in the cache; or
     * - The thread ID was already deleted from the cache; or
     * - The thread ID in the cache was updated more recently than the optimistic
     *   update's timestamp (if given)
     */
    private updateThread;
    patchThread(threadId: string, optimisticUpdateId: string | null, patch: {
        metadata?: M;
        resolved?: boolean;
    }, updatedAt: Date): void;
    addReaction(threadId: string, optimisticUpdateId: string | null, commentId: string, reaction: CommentUserReaction, createdAt: Date): void;
    removeReaction(threadId: string, optimisticUpdateId: string | null, commentId: string, emoji: string, userId: string, removedAt: Date): void;
    /**
     * Soft-deletes an existing thread by setting its `deletedAt` value,
     * replacing the corresponding optimistic update.
     *
     * This will not update anything if:
     * - The thread ID isn't found in the cache; or
     * - The thread ID was already deleted from the cache
     */
    deleteThread(threadId: string, optimisticUpdateId: string | null): void;
    /**
     * Creates an existing comment and ensures the associated notification is
     * updated correctly, replacing the corresponding optimistic update.
     */
    createComment(newComment: CommentData, optimisticUpdateId: string): void;
    editComment(threadId: string, optimisticUpdateId: string, editedComment: CommentData): void;
    deleteComment(threadId: string, optimisticUpdateId: string, commentId: string, deletedAt: Date): void;
    updateThreadAndNotification(thread: ThreadData<M>, inboxNotification?: InboxNotificationData): void;
    updateThreadsAndNotifications(threads: ThreadData<M>[], inboxNotifications: InboxNotificationData[]): void;
    updateThreadsAndNotifications(threads: ThreadData<M>[], inboxNotifications: InboxNotificationData[], deletedThreads: ThreadDeleteInfo[], deletedInboxNotifications: InboxNotificationDeleteInfo[]): void;
    /**
     * Updates existing notification setting for a room with a new value,
     * replacing the corresponding optimistic update.
     */
    updateRoomNotificationSettings_confirmOptimisticUpdate(roomId: string, optimisticUpdateId: string, settings: Readonly<RoomNotificationSettings$1>): void;
    addOptimisticUpdate(optimisticUpdate: DistributiveOmit<OptimisticUpdate<M>, "id">): string;
    removeOptimisticUpdate(optimisticUpdateId: string): void;
    fetchNotificationsDeltaUpdate(signal: AbortSignal): Promise<void>;
    waitUntilNotificationsLoaded(): UsablePromise<void>;
    waitUntilRoomThreadsLoaded(roomId: string, query: ThreadsQuery<M> | undefined): UsablePromise<void>;
    fetchRoomThreadsDeltaUpdate(roomId: string, signal: AbortSignal): Promise<void>;
    waitUntilUserThreadsLoaded(query: ThreadsQuery<M> | undefined): UsablePromise<void>;
    fetchUserThreadsDeltaUpdate(signal: AbortSignal): Promise<void>;
    waitUntilRoomVersionsLoaded(roomId: string): UsablePromise<void>;
    fetchRoomVersionsDeltaUpdate(roomId: string, signal: AbortSignal): Promise<void>;
    waitUntilRoomNotificationSettingsLoaded(roomId: string): UsablePromise<void>;
    refreshRoomNotificationSettings(roomId: string, signal: AbortSignal): Promise<void>;
}

/**
 * Raw access to the React context where the LiveblocksProvider stores the
 * current client. Exposed for advanced use cases only.
 *
 * @private This is a private/advanced API. Do not rely on it.
 */
declare const ClientContext: React__default.Context<OpaqueClient | null>;
/**
 * Gets or creates a unique Umbrella store for each unique client instance.
 *
 * @private
 */
declare function getUmbrellaStoreForClient<M extends BaseMetadata$1>(client: OpaqueClient): UmbrellaStore<M>;
/**
 * Obtains a reference to the current Liveblocks client.
 */
declare function useClient<U extends BaseUserMeta>(): Client$1<U, BaseMetadata$1>;
/**
 * Sets up a client for connecting to Liveblocks, and is the recommended way to do
 * this for React apps. You must define either `authEndpoint` or `publicApiKey`.
 * Resolver functions should be placed inside here, and a number of other options
 * are available, which correspond with those passed to `createClient`.
 * Unlike `RoomProvider`, `LiveblocksProvider` doesnâ€™t call Liveblocks servers when mounted,
 * and it should be placed higher in your appâ€™s component tree.
 */
declare function LiveblocksProvider<U extends BaseUserMeta = DU>(props: PropsWithChildren<ClientOptions<U>>): React__default.JSX.Element;
/**
 * Creates a LiveblocksProvider and a set of typed hooks. Note that any
 * LiveblocksProvider created in this way takes no props, because it uses
 * settings from the given client instead.
 */
declare function createLiveblocksContext<U extends BaseUserMeta = DU, M extends BaseMetadata$1 = DM>(client: OpaqueClient): LiveblocksContextBundle<U, M>;
/**
 * Returns the inbox notifications for the current user.
 *
 * @example
 * const { inboxNotifications, error, isLoading } = useInboxNotifications();
 */
declare function useInboxNotifications(): InboxNotificationsAsyncResult;
/**
 * Returns the inbox notifications for the current user.
 *
 * @example
 * const { inboxNotifications } = useInboxNotifications();
 */
declare function useInboxNotificationsSuspense(): {
    readonly isLoading: false;
    readonly inboxNotifications: InboxNotificationData[];
    readonly error?: undefined;
    hasFetchedAll: boolean;
    isFetchingMore: boolean;
    fetchMore: () => void;
    fetchMoreError?: Error | undefined;
};
/**
 * Returns a function that marks all of the current user's inbox notifications as read.
 *
 * @example
 * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();
 * markAllInboxNotificationsAsRead();
 */
declare function useMarkAllInboxNotificationsAsRead(): () => void;
/**
 * Returns a function that marks an inbox notification as read for the current user.
 *
 * @example
 * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
 * markInboxNotificationAsRead("in_xxx");
 */
declare function useMarkInboxNotificationAsRead(): (inboxNotificationId: string) => void;
/**
 * Returns a function that deletes all of the current user's inbox notifications.
 *
 * @example
 * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();
 * deleteAllInboxNotifications();
 */
declare function useDeleteAllInboxNotifications(): () => void;
/**
 * Returns a function that deletes an inbox notification for the current user.
 *
 * @example
 * const deleteInboxNotification = useDeleteInboxNotification();
 * deleteInboxNotification("in_xxx");
 */
declare function useDeleteInboxNotification(): (inboxNotificationId: string) => void;
/**
 * Returns the number of unread inbox notifications for the current user.
 *
 * @example
 * const { count, error, isLoading } = useUnreadInboxNotificationsCount();
 */
declare function useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountAsyncResult;
/**
 * Returns the number of unread inbox notifications for the current user.
 *
 * @example
 * const { count } = useUnreadInboxNotificationsCount();
 */
declare function useUnreadInboxNotificationsCountSuspense(): {
    readonly isLoading: false;
    readonly count: number;
    readonly error?: undefined;
};
/**
 * Returns room info from a given room ID.
 *
 * @example
 * const { info, error, isLoading } = useRoomInfo("room-id");
 */
declare function useRoomInfo(roomId: string): RoomInfoAsyncResult;
/**
 * Returns room info from a given room ID.
 *
 * @example
 * const { info } = useRoomInfo("room-id");
 */
declare function useRoomInfoSuspense(roomId: string): RoomInfoAsyncSuccess;
declare type TypedBundle = LiveblocksContextBundle<DU, DM>;
/**
 * Returns the thread associated with a `"thread"` inbox notification.
 *
 * It can **only** be called with IDs of `"thread"` inbox notifications,
 * so we recommend only using it when customizing the rendering or in other
 * situations where you can guarantee the kind of the notification.
 *
 * When `useInboxNotifications` returns `"thread"` inbox notifications,
 * it also receives the associated threads and caches them behind the scenes.
 * When you call `useInboxNotificationThread`, it simply returns the cached thread
 * for the inbox notification ID you passed to it, without any fetching or waterfalls.
 *
 * @example
 * const thread = useInboxNotificationThread("in_xxx");
 */
declare const _useInboxNotificationThread: TypedBundle["useInboxNotificationThread"];
/**
 * Returns user info from a given user ID.
 *
 * @example
 * const { user, error, isLoading } = useUser("user-id");
 */
declare const _useUser: TypedBundle["useUser"];
/**
 * Returns user info from a given user ID.
 *
 * @example
 * const { user } = useUser("user-id");
 */
declare const _useUserSuspense: TypedBundle["suspense"]["useUser"];
/**
 * @experimental
 *
 * This hook is experimental and could be removed or changed at any time!
 * Do not use unless explicitly recommended by the Liveblocks team.
 *
 * WARNING:
 * Please note that this hook currently returns all threads by most recently
 * updated threads first. This is inconsistent with the default sort order of
 * the useThreads() hook, which returns them in chronological order (by
 * creation date). In the final version, we will make these hooks behave
 * consistently, so expect that in the final version, you'll have to explicitly
 * specify the sort order to be by most recently updated first somehow.
 * The final API for that is still TBD.
 */
declare const _useUserThreads_experimental: TypedBundle["useUserThreads_experimental"];
/**
 * @experimental
 *
 * This hook is experimental and could be removed or changed at any time!
 * Do not use unless explicitly recommended by the Liveblocks team.
 *
 * WARNING:
 * Please note that this hook currently returns all threads by most recently
 * updated threads first. This is inconsistent with the default sort order of
 * the useThreads() hook, which returns them in chronological order (by
 * creation date). In the final version, we will make these hooks behave
 * consistently, so expect that in the final version, you'll have to explicitly
 * specify the sort order to be by most recently updated first somehow.
 * The final API for that is still TBD.
 */
declare const _useUserThreadsSuspense_experimental: TypedBundle["suspense"]["useUserThreads_experimental"];

export { type AttachmentUrlAsyncResult as A, CreateThreadError as C, type DeleteCommentOptions as D, type EditCommentOptions as E, type HistoryVersionDataAsyncResult as H, LiveblocksProvider as L, type MutationContext as M, type RoomContextBundle as R, type StorageStatusSuccess as S, type ThreadSubscription as T, type UseStorageStatusOptions as U, _useInboxNotificationThread as _, type CommentsError as a, type CreateCommentOptions as b, type CommentReactionOptions as c, type UseThreadsOptions as d, ClientContext as e, createLiveblocksContext as f, getUmbrellaStoreForClient as g, useMarkAllInboxNotificationsAsRead as h, useMarkInboxNotificationAsRead as i, useDeleteAllInboxNotifications as j, useDeleteInboxNotification as k, useInboxNotifications as l, _useUserThreads_experimental as m, useRoomInfo as n, useUnreadInboxNotificationsCount as o, _useUser as p, useInboxNotificationsSuspense as q, useRoomInfoSuspense as r, useUnreadInboxNotificationsCountSuspense as s, _useUserSuspense as t, useClient as u, _useUserThreadsSuspense_experimental as v };
