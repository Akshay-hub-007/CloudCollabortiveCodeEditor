{"version":3,"sources":["../src/use-mention-suggestions.ts"],"names":["mentionSuggestions"],"mappings":";;;;;;;;AAAA,SAAS,WAAW,iBAAiB;AACrC,OAAO,WAAW;AAKlB,IAAM,+BAA+B;AAQ9B,SAAS,sBAAsB,QAAiB;AACrD,QAAM,SAAS,UAAU;AAEzB,QAAM,OAAO,SAAQ;AACrB,QAAM,CAAC,oBAAoB,qBAAqB,IAC9C,MAAM,SAAmB;AAC3B,QAAM,gBAAgB,MAAM,OAAe;AAE3C,QAAM,UAAU,MAAM;AACpB,UAAM,0BAA0B,OAAO,SAAS,EAAE;AAClD,UAAM,4BACJ,OAAO,SAAS,EAAE;AAEpB,QAAI,WAAW,UAAa,CAAC,2BAA2B;AACtD;AAAA,IACF;AAEA,UAAM,gCAAgC,EAAE,MAAM,QAAQ,QAAQ,KAAK,GAAG;AACtE,UAAM,6BAA6B,UAAU,6BAA6B;AAC1E,QAAI;AACJ,QAAI,aAAa;AAEjB,UAAM,wBAAwB,YAAY;AACxC,UAAI;AACF,sBAAc,UAAU,YAAY,IAAI;AACxC,cAAMA,sBAAqB,MAAM;AAAA,UAC/B;AAAA,QACF;AAEA,YAAI,CAAC,YAAY;AACf,gCAAsBA,mBAAkB;AACxC,kCAAwB;AAAA,YACtB;AAAA,YACAA;AAAA,UACF;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,MAAO,OAAiB,OAAO;AAAA,MACzC;AAAA,IACF;AAEA,QAAI,wBAAwB,IAAI,0BAA0B,GAAG;AAE3D;AAAA,QACE,wBAAwB,IAAI,0BAA0B;AAAA,MACxD;AAAA,IACF,WACE,CAAC,cAAc,WACf,KAAK,IAAI,YAAY,IAAI,IAAI,cAAc,OAAO,IAChD,8BACF;AAGA,WAAK,sBAAsB;AAAA,IAC7B,OAAO;AAEL,wBAAkB,OAAO,WAAW,MAAM;AACxC,aAAK,sBAAsB;AAAA,MAC7B,GAAG,4BAA4B;AAAA,IACjC;AAEA,WAAO,MAAM;AACX,mBAAa;AACb,aAAO,aAAa,eAAe;AAAA,IACrC;AAAA,EACF,GAAG,CAAC,QAAQ,KAAK,IAAI,MAAM,CAAC;AAE5B,SAAO;AACT","sourcesContent":["import { kInternal, stringify } from \"@liveblocks/core\";\nimport React from \"react\";\n\nimport { useClient } from \"./liveblocks\";\nimport { useRoom } from \"./room\";\n\nconst MENTION_SUGGESTIONS_DEBOUNCE = 500;\n\n/**\n * @private For internal use only. Do not rely on this hook.\n *\n * Simplistic debounced search, we don't need to worry too much about deduping\n * and race conditions as there can only be one search at a time.\n */\nexport function useMentionSuggestions(search?: string) {\n  const client = useClient();\n\n  const room = useRoom();\n  const [mentionSuggestions, setMentionSuggestions] =\n    React.useState<string[]>();\n  const lastInvokedAt = React.useRef<number>();\n\n  React.useEffect(() => {\n    const mentionSuggestionsCache = client[kInternal].mentionSuggestionsCache;\n    const resolveMentionSuggestions =\n      client[kInternal].resolveMentionSuggestions;\n\n    if (search === undefined || !resolveMentionSuggestions) {\n      return;\n    }\n\n    const resolveMentionSuggestionsArgs = { text: search, roomId: room.id };\n    const mentionSuggestionsCacheKey = stringify(resolveMentionSuggestionsArgs);\n    let debounceTimeout: number | undefined;\n    let isCanceled = false;\n\n    const getMentionSuggestions = async () => {\n      try {\n        lastInvokedAt.current = performance.now();\n        const mentionSuggestions = await resolveMentionSuggestions(\n          resolveMentionSuggestionsArgs\n        );\n\n        if (!isCanceled) {\n          setMentionSuggestions(mentionSuggestions);\n          mentionSuggestionsCache.set(\n            mentionSuggestionsCacheKey,\n            mentionSuggestions\n          );\n        }\n      } catch (error) {\n        console.error((error as Error)?.message);\n      }\n    };\n\n    if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n      // If there are already cached mention suggestions, use them immediately.\n      setMentionSuggestions(\n        mentionSuggestionsCache.get(mentionSuggestionsCacheKey)\n      );\n    } else if (\n      !lastInvokedAt.current ||\n      Math.abs(performance.now() - lastInvokedAt.current) >\n        MENTION_SUGGESTIONS_DEBOUNCE\n    ) {\n      // If on the debounce's leading edge (either because it's the first invokation or enough\n      // time has passed since the last debounce), get mention suggestions immediately.\n      void getMentionSuggestions();\n    } else {\n      // Otherwise, wait for the debounce delay.\n      debounceTimeout = window.setTimeout(() => {\n        void getMentionSuggestions();\n      }, MENTION_SUGGESTIONS_DEBOUNCE);\n    }\n\n    return () => {\n      isCanceled = true;\n      window.clearTimeout(debounceTimeout);\n    };\n  }, [client, room.id, search]);\n\n  return mentionSuggestions;\n}\n"]}