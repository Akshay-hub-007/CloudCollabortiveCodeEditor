// src/contexts.ts
import * as React from "react";
var RoomContext = React.createContext(null);
function useRoomOrNull() {
  return React.useContext(RoomContext);
}
function useIsInsideRoom() {
  const room = useRoomOrNull();
  return room !== null;
}

// src/liveblocks.tsx
import {
  assert,
  createClient,
  kInternal as kInternal2,
  makePoller,
  raise,
  shallow as shallow3
} from "@liveblocks/core";
import React2, {
  createContext as createContext2,
  useCallback as useCallback2,
  useContext as useContext2,
  useEffect as useEffect2,
  useMemo
} from "react";
import { useSyncExternalStore } from "use-sync-external-store/shim/index.js";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/shim/with-selector.js";

// src/config.ts
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var config = {
  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,
  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,
  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,
  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,
  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,
  USER_THREADS_MAX_STALE_TIME: 5 * SECONDS,
  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,
  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,
  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,
  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS
};

// src/lib/shallow2.ts
import { isPlainObject, shallow } from "@liveblocks/core";
function shallow2(a, b) {
  if (!isPlainObject(a) || !isPlainObject(b)) {
    return shallow(a, b);
  }
  const keysA = Object.keys(a);
  if (keysA.length !== Object.keys(b).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])
  );
}

// src/lib/use-initial.ts
import { useCallback, useReducer } from "react";

// src/lib/use-latest.ts
import { useEffect, useRef } from "react";
function useLatest(value) {
  const ref = useRef(value);
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/lib/use-initial.ts
var noop = (state) => state;
function useInitial(value) {
  return useReducer(noop, value)[0];
}
function useInitialUnlessFunction(latestValue) {
  const frozenValue = useInitial(latestValue);
  if (typeof frozenValue === "function") {
    const ref = useLatest(latestValue);
    return useCallback((...args) => ref.current(...args), [
      ref
    ]);
  } else {
    return frozenValue;
  }
}

// src/lib/use-polyfill.ts
var use = (
  // React.use ||
  (promise) => {
    if (promise.status === "pending") {
      throw promise;
    } else if (promise.status === "fulfilled") {
      return promise.value;
    } else if (promise.status === "rejected") {
      throw promise.reason;
    } else {
      promise.status = "pending";
      promise.then(
        (v) => {
          promise.status = "fulfilled";
          promise.value = v;
        },
        (e) => {
          promise.status = "rejected";
          promise.reason = e;
        }
      );
      throw promise;
    }
  }
);

// src/umbrella-store.ts
import {
  autoRetry,
  compactObject,
  console as console2,
  createStore,
  HttpError,
  kInternal,
  makeEventSource,
  mapValues,
  nanoid,
  nn,
  stringify
} from "@liveblocks/core";

// src/lib/autobind.ts
function autobind(self) {
  const seen = /* @__PURE__ */ new Set();
  seen.add("constructor");
  let obj = self.constructor.prototype;
  do {
    for (const key of Reflect.ownKeys(obj)) {
      if (seen.has(key)) continue;
      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
      if (typeof descriptor?.value === "function") {
        seen.add(key);
        self[key] = self[key].bind(self);
      }
    }
  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);
}

// src/ThreadDB.ts
import { SortedList } from "@liveblocks/core";

// src/lib/guards.ts
import { isPlainObject as isPlainObject2 } from "@liveblocks/core";
function isStartsWith(blob) {
  return isPlainObject2(blob) && isString(blob.startsWith);
}
function isString(value) {
  return typeof value === "string";
}

// src/lib/querying.ts
function makeThreadsFilter(query) {
  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);
}
function matchesQuery(thread, q) {
  return q.resolved === void 0 || thread.resolved === q.resolved;
}
function matchesMetadata(thread, q) {
  const metadata = thread.metadata;
  return q.metadata === void 0 || Object.entries(q.metadata).every(
    ([key, op]) => (
      // NOTE: `op` can be explicitly-`undefined` here, which ideally would not
      // mean "filter for absence" like it does now, as this does not match the
      // backend behavior at the moment. For an in-depth discussion, see
      // https://liveblocks.slack.com/archives/C02PZL7QAAW/p1728546988505989
      matchesOperator(metadata[key], op)
    )
  );
}
function matchesOperator(value, op) {
  if (isStartsWith(op)) {
    return isString(value) && value.startsWith(op.startsWith);
  } else {
    return value === op;
  }
}

// src/ThreadDB.ts
function sanitizeThread(thread) {
  if (thread.deletedAt) {
    if (thread.comments.length > 0) {
      return { ...thread, comments: [] };
    }
  }
  const hasComment = thread.comments.some((c) => !c.deletedAt);
  if (!hasComment) {
    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };
  }
  return thread;
}
var ThreadDB = class _ThreadDB {
  // The version is auto-incremented on every mutation and can be used as a reliable indicator to tell if the contents of the thread pool has changed
  constructor() {
    this._asc = SortedList.from([], (t1, t2) => {
      const d1 = t1.createdAt;
      const d2 = t2.createdAt;
      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;
    });
    this._desc = SortedList.from([], (t1, t2) => {
      const d2 = t2.updatedAt;
      const d1 = t1.updatedAt;
      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;
    });
    this._byId = /* @__PURE__ */ new Map();
    this._version = 0;
  }
  //
  // Public APIs
  //
  clone() {
    const newPool = new _ThreadDB();
    newPool._byId = new Map(this._byId);
    newPool._asc = this._asc.clone();
    newPool._desc = this._desc.clone();
    newPool._version = this._version;
    return newPool;
  }
  /** Gets the transaction count for this DB. Increments any time the DB is modified. */
  get version() {
    return this._version;
  }
  /** Returns an existing thread by ID. Will never return a deleted thread. */
  get(threadId) {
    const thread = this.getEvenIfDeleted(threadId);
    return thread?.deletedAt ? void 0 : thread;
  }
  /** Returns the (possibly deleted) thread by ID. */
  getEvenIfDeleted(threadId) {
    return this._byId.get(threadId);
  }
  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */
  upsert(thread) {
    thread = sanitizeThread(thread);
    const id = thread.id;
    const toRemove = this._byId.get(id);
    if (toRemove) {
      if (toRemove.deletedAt) return;
      this._asc.remove(toRemove);
      this._desc.remove(toRemove);
    }
    if (!thread.deletedAt) {
      this._asc.add(thread);
      this._desc.add(thread);
    }
    this._byId.set(id, thread);
    this.touch();
  }
  /** Like .upsert(), except it won't update if a thread by this ID already exists. */
  // TODO Consider renaming this to just .upsert(). I'm not sure if we really
  // TODO need the raw .upsert(). Would be nice if this behavior was the default.
  upsertIfNewer(thread) {
    const existing = this.get(thread.id);
    if (!existing || thread.updatedAt >= existing.updatedAt) {
      this.upsert(thread);
    }
  }
  /**
   * Marks a thread as deleted. It will no longer pop up in .findMany()
   * queries, but it can still be accessed via `.getEvenIfDeleted()`.
   */
  delete(threadId, deletedAt) {
    const existing = this._byId.get(threadId);
    if (existing && !existing.deletedAt) {
      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });
    }
  }
  /**
   * Returns all threads matching a given roomId and query. If roomId is not
   * specified, it will return all threads matching the query, across all
   * rooms.
   *
   * Returns the results in the requested order. Please note:
   *   'asc'  means by createdAt ASC
   *   'desc' means by updatedAt DESC
   *
   * Will never return deleted threads in the result.
   */
  findMany(roomId, query, direction) {
    const index = direction === "desc" ? this._desc : this._asc;
    const crit = [];
    if (roomId !== void 0) {
      crit.push((t) => t.roomId === roomId);
    }
    crit.push(makeThreadsFilter(query));
    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));
  }
  //
  // Private APIs
  //
  touch() {
    ++this._version;
  }
};

// src/umbrella-store.ts
function makeRoomThreadsQueryKey(roomId, query) {
  return `${roomId}-${stringify(query ?? {})}`;
}
function makeUserThreadsQueryKey(query) {
  return `USER_THREADS:${stringify(query ?? {})}`;
}
function makeNotificationSettingsQueryKey(roomId) {
  return `${roomId}:NOTIFICATION_SETTINGS`;
}
function makeVersionsQueryKey(roomId) {
  return `${roomId}-VERSIONS`;
}
function usify(promise) {
  if ("status" in promise) {
    return promise;
  }
  const usable = promise;
  usable.status = "pending";
  usable.then(
    (value) => {
      usable.status = "fulfilled";
      usable.value = value;
    },
    (err) => {
      usable.status = "rejected";
      usable.reason = err;
    }
  );
  return usable;
}
var noop2 = Promise.resolve();
var ASYNC_LOADING = Object.freeze({ isLoading: true });
var PaginatedResource = class {
  constructor(fetchPage) {
    this._cachedPromise = null;
    this._paginationState = null;
    this._fetchPage = fetchPage;
    this._eventSource = makeEventSource();
    this._pendingFetchMore = null;
    this.observable = this._eventSource.observable;
    autobind(this);
  }
  patchPaginationState(patch) {
    const state = this._paginationState;
    if (state === null) return;
    this._paginationState = { ...state, ...patch };
    this._eventSource.notify();
  }
  async _fetchMore() {
    const state = this._paginationState;
    if (!state?.cursor) {
      return;
    }
    this.patchPaginationState({ isFetchingMore: true });
    try {
      const nextCursor = await this._fetchPage(state.cursor);
      this.patchPaginationState({
        cursor: nextCursor,
        fetchMoreError: void 0,
        isFetchingMore: false
      });
    } catch (err) {
      this.patchPaginationState({
        isFetchingMore: false,
        fetchMoreError: err
      });
    }
  }
  fetchMore() {
    const state = this._paginationState;
    if (state?.cursor === null) {
      return noop2;
    }
    if (!this._pendingFetchMore) {
      this._pendingFetchMore = this._fetchMore().finally(() => {
        this._pendingFetchMore = null;
      });
    }
    return this._pendingFetchMore;
  }
  get() {
    const usable = this._cachedPromise;
    if (usable === null || usable.status === "pending") {
      return ASYNC_LOADING;
    }
    if (usable.status === "rejected") {
      return { isLoading: false, error: usable.reason };
    }
    const state = this._paginationState;
    return {
      isLoading: false,
      data: {
        fetchMore: this.fetchMore,
        isFetchingMore: state.isFetchingMore,
        fetchMoreError: state.fetchMoreError,
        hasFetchedAll: state.cursor === null
      }
    };
  }
  waitUntilLoaded() {
    if (this._cachedPromise) {
      return this._cachedPromise;
    }
    const initialFetcher = autoRetry(
      () => this._fetchPage(
        /* cursor */
        void 0
      ),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(
      initialFetcher.then((cursor) => {
        this._paginationState = {
          cursor,
          isFetchingMore: false,
          fetchMoreError: void 0
        };
      })
    );
    promise.then(
      () => this._eventSource.notify(),
      () => {
        this._eventSource.notify();
        setTimeout(() => {
          this._cachedPromise = null;
          this._eventSource.notify();
        }, 5e3);
      }
    );
    this._cachedPromise = promise;
    return promise;
  }
};
var SinglePageResource = class {
  constructor(fetchPage) {
    this._cachedPromise = null;
    this._fetchPage = fetchPage;
    this._eventSource = makeEventSource();
    this.observable = this._eventSource.observable;
    autobind(this);
  }
  get() {
    const usable = this._cachedPromise;
    if (usable === null || usable.status === "pending") {
      return ASYNC_LOADING;
    }
    if (usable.status === "rejected") {
      return { isLoading: false, error: usable.reason };
    }
    return {
      isLoading: false,
      data: void 0
    };
  }
  waitUntilLoaded() {
    if (this._cachedPromise) {
      return this._cachedPromise;
    }
    const initialFetcher = autoRetry(
      () => this._fetchPage(),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialFetcher);
    promise.then(
      () => this._eventSource.notify(),
      () => {
        this._eventSource.notify();
        setTimeout(() => {
          this._cachedPromise = null;
          this._eventSource.notify();
        }, 5e3);
      }
    );
    this._cachedPromise = promise;
    return promise;
  }
};
var UmbrellaStore = class {
  constructor(client) {
    this._prevVersion = -1;
    this._prevState = null;
    this._stateCached = null;
    // Notifications
    this._notificationsLastRequestedAt = null;
    // Room Threads
    this._roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
    this._roomThreads = /* @__PURE__ */ new Map();
    // User Threads
    this._userThreadsLastRequestedAt = null;
    this._userThreads = /* @__PURE__ */ new Map();
    // Room versions
    this._roomVersions = /* @__PURE__ */ new Map();
    this._roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
    // Room notification settings
    this._roomNotificationSettings = /* @__PURE__ */ new Map();
    this._client = client[kInternal].as();
    const inboxFetcher = async (cursor) => {
      const result = await this._client.getInboxNotifications({ cursor });
      this.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications
      );
      if (this._notificationsLastRequestedAt === null) {
        this._notificationsLastRequestedAt = result.requestedAt;
      }
      const nextCursor = result.nextCursor;
      return nextCursor;
    };
    this._notifications = new PaginatedResource(inboxFetcher);
    this._notifications.observable.subscribe(
      () => (
        // Note that the store itself does not change, but it's only vehicle at
        // the moment to trigger a re-render, so we'll do a no-op update here.
        this._store.set((store) => ({ ...store }))
      )
    );
    this._rawThreadsDB = new ThreadDB();
    this._store = createStore({
      optimisticUpdates: [],
      notificationsById: {},
      settingsByRoomId: {},
      versionsByRoomId: {}
    });
    autobind(this);
  }
  get() {
    const rawState = this._store.get();
    if (this._prevVersion !== this._rawThreadsDB.version || // Note: Version check is only needed temporarily, until we can get rid of the Zustand-like update model
    this._prevState !== rawState || this._stateCached === null) {
      this._stateCached = internalToExternalState(rawState, this._rawThreadsDB);
      this._prevState = rawState;
      this._prevVersion = this._rawThreadsDB.version;
    }
    return this._stateCached;
  }
  batch(callback) {
    return this._store.batch(callback);
  }
  getFullState() {
    return this.get();
  }
  /**
   * Returns the async result of the given query and room id. If the query is success,
   * then it will return the threads that match that provided query and room id.
   *
   */
  getRoomThreadsLoadingState(roomId, query) {
    const queryKey = makeRoomThreadsQueryKey(roomId, query);
    const paginatedResource = this._roomThreads.get(queryKey);
    if (paginatedResource === void 0) {
      return ASYNC_LOADING;
    }
    const asyncResult = paginatedResource.get();
    if (asyncResult.isLoading || asyncResult.error) {
      return asyncResult;
    }
    const threads = this.getFullState().threadsDB.findMany(
      roomId,
      query ?? {},
      "asc"
    );
    const page = asyncResult.data;
    return {
      isLoading: false,
      threads,
      hasFetchedAll: page.hasFetchedAll,
      isFetchingMore: page.isFetchingMore,
      fetchMoreError: page.fetchMoreError,
      fetchMore: page.fetchMore
    };
  }
  getUserThreadsLoadingState(query) {
    const queryKey = makeUserThreadsQueryKey(query);
    const paginatedResource = this._userThreads.get(queryKey);
    if (paginatedResource === void 0) {
      return ASYNC_LOADING;
    }
    const asyncResult = paginatedResource.get();
    if (asyncResult.isLoading || asyncResult.error) {
      return asyncResult;
    }
    const threads = this.getFullState().threadsDB.findMany(
      void 0,
      // Do _not_ filter by roomId
      query ?? {},
      "desc"
    );
    const page = asyncResult.data;
    return {
      isLoading: false,
      threads,
      hasFetchedAll: page.hasFetchedAll,
      isFetchingMore: page.isFetchingMore,
      fetchMoreError: page.fetchMoreError,
      fetchMore: page.fetchMore
    };
  }
  // NOTE: This will read the async result, but WILL NOT start loading at the moment!
  getInboxNotificationsLoadingState() {
    const asyncResult = this._notifications.get();
    if (asyncResult.isLoading || asyncResult.error) {
      return asyncResult;
    }
    const page = asyncResult.data;
    return {
      isLoading: false,
      inboxNotifications: this.getFullState().cleanedNotifications,
      hasFetchedAll: page.hasFetchedAll,
      isFetchingMore: page.isFetchingMore,
      fetchMoreError: page.fetchMoreError,
      fetchMore: page.fetchMore
    };
  }
  // NOTE: This will read the async result, but WILL NOT start loading at the moment!
  getNotificationSettingsLoadingState(roomId) {
    const queryKey = makeNotificationSettingsQueryKey(roomId);
    const resource = this._roomNotificationSettings.get(queryKey);
    if (resource === void 0) {
      return ASYNC_LOADING;
    }
    const asyncResult = resource.get();
    if (asyncResult.isLoading || asyncResult.error) {
      return asyncResult;
    }
    return {
      isLoading: false,
      settings: nn(this.get().settingsByRoomId[roomId])
    };
  }
  getRoomVersionsLoadingState(roomId) {
    const queryKey = makeVersionsQueryKey(roomId);
    const resource = this._roomVersions.get(queryKey);
    if (resource === void 0) {
      return ASYNC_LOADING;
    }
    const asyncResult = resource.get();
    if (asyncResult.isLoading || asyncResult.error) {
      return asyncResult;
    }
    return {
      isLoading: false,
      versions: Object.values(this.get().versionsByRoomId[roomId] ?? {})
    };
  }
  /**
   * @private Only used by the E2E test suite.
   */
  _hasOptimisticUpdates() {
    return this._store.get().optimisticUpdates.length > 0;
  }
  subscribe(callback) {
    return this._store.subscribe(callback);
  }
  // Direct low-level cache mutations ------------------------------------------------- {{{
  mutateThreadsDB(mutate) {
    const db = this._rawThreadsDB;
    const old = db.version;
    mutate(db);
    if (old !== db.version) {
      this._store.set((state) => ({ ...state }));
    }
  }
  updateInboxNotificationsCache(mapFn) {
    this._store.set((state) => {
      const inboxNotifications = mapFn(state.notificationsById);
      return inboxNotifications !== state.notificationsById ? { ...state, notificationsById: inboxNotifications } : state;
    });
  }
  setNotificationSettings(roomId, settings) {
    this._store.set((state) => ({
      ...state,
      settingsByRoomId: {
        ...state.settingsByRoomId,
        [roomId]: settings
      }
    }));
  }
  updateRoomVersions(roomId, versions) {
    this._store.set((state) => {
      const versionsById = Object.fromEntries(
        versions.map((version2) => [version2.id, version2])
      );
      return {
        ...state,
        versionsByRoomId: {
          ...state.versionsByRoomId,
          [roomId]: {
            // Merge with existing versions for the room, or start with an empty object
            ...state.versionsByRoomId[roomId] ?? {},
            ...versionsById
          }
        }
      };
    });
  }
  updateOptimisticUpdatesCache(mapFn) {
    this._store.set((state) => ({
      ...state,
      optimisticUpdates: mapFn(state.optimisticUpdates)
    }));
  }
  // ---------------------------------------------------------------------------------- }}}
  /** @internal - Only call this method from unit tests. */
  force_set(callback) {
    return this._store.set(callback);
  }
  /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found in
   * the cache.
   */
  updateInboxNotification(inboxNotificationId, optimisticUpdateId, callback) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache((cache) => {
        const existing = cache[inboxNotificationId];
        if (!existing) {
          return cache;
        }
        const inboxNotifications = {
          ...cache,
          [inboxNotificationId]: callback(existing)
        };
        return inboxNotifications;
      });
    });
  }
  /**
   * Updates *all* inbox notifications by running a mapper function over all of
   * them, replacing the corresponding optimistic update.
   */
  updateAllInboxNotifications(optimisticUpdateId, mapFn) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache((cache) => mapValues(cache, mapFn));
    });
  }
  /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */
  deleteInboxNotification(inboxNotificationId, optimisticUpdateId) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache((cache) => {
        const { [inboxNotificationId]: removed, ...newCache } = cache;
        return removed === void 0 ? cache : newCache;
      });
    });
  }
  /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */
  deleteAllInboxNotifications(optimisticUpdateId) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.updateInboxNotificationsCache(() => ({}));
    });
  }
  /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */
  createThread(optimisticUpdateId, thread) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.mutateThreadsDB((db) => db.upsert(thread));
    });
  }
  /**
   * Updates an existing thread with a new value, replacing the corresponding
   * optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found in the cache; or
   * - The thread ID was already deleted from the cache; or
   * - The thread ID in the cache was updated more recently than the optimistic
   *   update's timestamp (if given)
   */
  updateThread(threadId, optimisticUpdateId, callback, updatedAt) {
    this._store.batch(() => {
      if (optimisticUpdateId !== null) {
        this.removeOptimisticUpdate(optimisticUpdateId);
      }
      this.mutateThreadsDB((db) => {
        const existing = db.get(threadId);
        if (!existing) return;
        if (!!updatedAt && existing.updatedAt > updatedAt) return;
        db.upsert(callback(existing));
      });
    });
  }
  patchThread(threadId, optimisticUpdateId, patch, updatedAt) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => ({ ...thread, ...compactObject(patch) }),
      updatedAt
    );
  }
  addReaction(threadId, optimisticUpdateId, commentId, reaction, createdAt) {
    this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyAddReaction(thread, commentId, reaction),
      createdAt
    );
  }
  removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt) {
    this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),
      removedAt
    );
  }
  /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found in the cache; or
   * - The thread ID was already deleted from the cache
   */
  deleteThread(threadId, optimisticUpdateId) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      // A deletion is actually an update of the deletedAt property internally
      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })
    );
  }
  /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */
  createComment(newComment, optimisticUpdateId) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      const existingThread = this._rawThreadsDB.get(newComment.threadId);
      if (!existingThread) {
        return;
      }
      this.mutateThreadsDB(
        (db) => db.upsert(applyUpsertComment(existingThread, newComment))
      );
      this.updateInboxNotificationsCache((cache) => {
        const existingNotification = Object.values(cache).find(
          (notification) => notification.kind === "thread" && notification.threadId === newComment.threadId
        );
        if (!existingNotification) {
          return cache;
        }
        return {
          ...cache,
          [existingNotification.id]: {
            ...existingNotification,
            notifiedAt: newComment.createdAt,
            readAt: newComment.createdAt
          }
        };
      });
    });
  }
  editComment(threadId, optimisticUpdateId, editedComment) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyUpsertComment(thread, editedComment)
    );
  }
  deleteComment(threadId, optimisticUpdateId, commentId, deletedAt) {
    return this.updateThread(
      threadId,
      optimisticUpdateId,
      (thread) => applyDeleteComment(thread, commentId, deletedAt),
      deletedAt
    );
  }
  updateThreadAndNotification(thread, inboxNotification) {
    this._store.batch(() => {
      this.mutateThreadsDB((db) => db.upsertIfNewer(thread));
      if (inboxNotification !== void 0) {
        this.updateInboxNotificationsCache((cache) => ({
          ...cache,
          [inboxNotification.id]: inboxNotification
        }));
      }
    });
  }
  updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads = [], deletedInboxNotifications = []) {
    this._store.batch(() => {
      this.mutateThreadsDB(
        (db) => applyThreadDeltaUpdates(db, { newThreads: threads, deletedThreads })
      );
      this.updateInboxNotificationsCache(
        (cache) => applyNotificationsUpdates(cache, {
          newInboxNotifications: inboxNotifications,
          deletedNotifications: deletedInboxNotifications
        })
      );
    });
  }
  /**
   * Updates existing notification setting for a room with a new value,
   * replacing the corresponding optimistic update.
   */
  updateRoomNotificationSettings_confirmOptimisticUpdate(roomId, optimisticUpdateId, settings) {
    this._store.batch(() => {
      this.removeOptimisticUpdate(optimisticUpdateId);
      this.setNotificationSettings(roomId, settings);
    });
  }
  addOptimisticUpdate(optimisticUpdate) {
    const id = nanoid();
    const newUpdate = { ...optimisticUpdate, id };
    this.updateOptimisticUpdatesCache((cache) => [...cache, newUpdate]);
    return id;
  }
  removeOptimisticUpdate(optimisticUpdateId) {
    this.updateOptimisticUpdatesCache(
      (cache) => cache.filter((ou) => ou.id !== optimisticUpdateId)
    );
  }
  async fetchNotificationsDeltaUpdate(signal) {
    const lastRequestedAt = this._notificationsLastRequestedAt;
    if (lastRequestedAt === null) {
      return;
    }
    const result = await this._client.getInboxNotificationsSince({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      this._notificationsLastRequestedAt = result.requestedAt;
    }
    this.updateThreadsAndNotifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted
    );
  }
  waitUntilNotificationsLoaded() {
    return this._notifications.waitUntilLoaded();
  }
  waitUntilRoomThreadsLoaded(roomId, query) {
    const threadsFetcher = async (cursor) => {
      const room = this._client.getRoom(roomId);
      if (room === null) {
        throw new HttpError(`Room '${roomId}' is not available on client`, 479);
      }
      const result = await room.getThreads({ cursor, query });
      this.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications
      );
      const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);
      if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
        this._roomThreadsLastRequestedAtByRoom.set(roomId, result.requestedAt);
      }
      return result.nextCursor;
    };
    const queryKey = makeRoomThreadsQueryKey(roomId, query);
    let paginatedResource = this._roomThreads.get(queryKey);
    if (paginatedResource === void 0) {
      paginatedResource = new PaginatedResource(threadsFetcher);
    }
    paginatedResource.observable.subscribe(
      () => (
        // Note that the store itself does not change, but it's only vehicle at
        // the moment to trigger a re-render, so we'll do a no-op update here.
        this._store.set((store) => ({ ...store }))
      )
    );
    this._roomThreads.set(queryKey, paginatedResource);
    return paginatedResource.waitUntilLoaded();
  }
  async fetchRoomThreadsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const room = nn(
      this._client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const updates = await room.getThreadsSince({
      since: lastRequestedAt,
      signal
    });
    this.updateThreadsAndNotifications(
      updates.threads.updated,
      updates.inboxNotifications.updated,
      updates.threads.deleted,
      updates.inboxNotifications.deleted
    );
    if (lastRequestedAt < updates.requestedAt) {
      this._roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
    }
  }
  waitUntilUserThreadsLoaded(query) {
    const queryKey = makeUserThreadsQueryKey(query);
    const threadsFetcher = async (cursor) => {
      const result = await this._client[kInternal].getUserThreads_experimental({
        cursor,
        query
      });
      this.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications
      );
      if (this._userThreadsLastRequestedAt === null) {
        this._userThreadsLastRequestedAt = result.requestedAt;
      }
      return result.nextCursor;
    };
    let paginatedResource = this._userThreads.get(queryKey);
    if (paginatedResource === void 0) {
      paginatedResource = new PaginatedResource(threadsFetcher);
    }
    paginatedResource.observable.subscribe(
      () => (
        // Note that the store itself does not change, but it's only vehicle at
        // the moment to trigger a re-render, so we'll do a no-op update here.
        this._store.set((store) => ({ ...store }))
      )
    );
    this._userThreads.set(queryKey, paginatedResource);
    return paginatedResource.waitUntilLoaded();
  }
  async fetchUserThreadsDeltaUpdate(signal) {
    const lastRequestedAt = this._userThreadsLastRequestedAt;
    if (lastRequestedAt === null) {
      return;
    }
    const result = await this._client[kInternal].getUserThreadsSince_experimental({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      this._notificationsLastRequestedAt = result.requestedAt;
    }
    this.updateThreadsAndNotifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted
    );
  }
  waitUntilRoomVersionsLoaded(roomId) {
    const queryKey = makeVersionsQueryKey(roomId);
    let resource = this._roomVersions.get(queryKey);
    if (resource === void 0) {
      const versionsFetcher = async () => {
        const room = this._client.getRoom(roomId);
        if (room === null) {
          throw new HttpError(
            `Room '${roomId}' is not available on client`,
            479
          );
        }
        const result = await room[kInternal].listTextVersions();
        this.updateRoomVersions(roomId, result.versions);
        const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);
        if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
          this._roomVersionsLastRequestedAtByRoom.set(
            roomId,
            result.requestedAt
          );
        }
      };
      resource = new SinglePageResource(versionsFetcher);
    }
    resource.observable.subscribe(
      () => (
        // Note that the store itself does not change, but it's only vehicle at
        // the moment to trigger a re-render, so we'll do a no-op update here.
        this._store.set((store) => ({ ...store }))
      )
    );
    this._roomVersions.set(queryKey, resource);
    return resource.waitUntilLoaded();
  }
  async fetchRoomVersionsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const room = nn(
      this._client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const updates = await room[kInternal].listTextVersionsSince({
      since: lastRequestedAt,
      signal
    });
    this.updateRoomVersions(roomId, updates.versions);
    if (lastRequestedAt < updates.requestedAt) {
      this._roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
    }
  }
  waitUntilRoomNotificationSettingsLoaded(roomId) {
    const queryKey = makeNotificationSettingsQueryKey(roomId);
    let resource = this._roomNotificationSettings.get(queryKey);
    if (resource === void 0) {
      const notificationSettingsFetcher = async () => {
        const room = this._client.getRoom(roomId);
        if (room === null) {
          throw new HttpError(
            `Room '${roomId}' is not available on client`,
            479
          );
        }
        const result = await room.getNotificationSettings();
        this.setNotificationSettings(roomId, result);
      };
      resource = new SinglePageResource(notificationSettingsFetcher);
    }
    resource.observable.subscribe(
      () => (
        // Note that the store itself does not change, but it's only vehicle at
        // the moment to trigger a re-render, so we'll do a no-op update here.
        this._store.set((store) => ({ ...store }))
      )
    );
    this._roomNotificationSettings.set(queryKey, resource);
    return resource.waitUntilLoaded();
  }
  async refreshRoomNotificationSettings(roomId, signal) {
    const room = nn(
      this._client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const result = await room.getNotificationSettings({ signal });
    this.setNotificationSettings(roomId, result);
  }
};
function internalToExternalState(state, rawThreadsDB) {
  const threadsDB = rawThreadsDB.clone();
  const computed = {
    notificationsById: { ...state.notificationsById },
    settingsByRoomId: { ...state.settingsByRoomId }
  };
  for (const optimisticUpdate of state.optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "create-thread": {
        threadsDB.upsert(optimisticUpdate.thread);
        break;
      }
      case "edit-thread-metadata": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        if (thread.updatedAt > optimisticUpdate.updatedAt) {
          break;
        }
        threadsDB.upsert({
          ...thread,
          updatedAt: optimisticUpdate.updatedAt,
          metadata: {
            ...thread.metadata,
            ...optimisticUpdate.metadata
          }
        });
        break;
      }
      case "mark-thread-as-resolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: true });
        break;
      }
      case "mark-thread-as-unresolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: false });
        break;
      }
      case "create-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        const inboxNotification = Object.values(
          computed.notificationsById
        ).find(
          (notification) => notification.kind === "thread" && notification.threadId === thread.id
        );
        if (inboxNotification === void 0) {
          break;
        }
        computed.notificationsById[inboxNotification.id] = {
          ...inboxNotification,
          notifiedAt: optimisticUpdate.comment.createdAt,
          readAt: optimisticUpdate.comment.createdAt
        };
        break;
      }
      case "edit-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        break;
      }
      case "delete-comment": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyDeleteComment(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.deletedAt
          )
        );
        break;
      }
      case "delete-thread": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({
          ...thread,
          deletedAt: optimisticUpdate.deletedAt,
          updatedAt: optimisticUpdate.deletedAt,
          comments: []
        });
        break;
      }
      case "add-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyAddReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.reaction
          )
        );
        break;
      }
      case "remove-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyRemoveReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.emoji,
            optimisticUpdate.userId,
            optimisticUpdate.removedAt
          )
        );
        break;
      }
      case "mark-inbox-notification-as-read": {
        const ibn = computed.notificationsById[optimisticUpdate.inboxNotificationId];
        if (ibn === void 0) {
          break;
        }
        computed.notificationsById[optimisticUpdate.inboxNotificationId] = {
          ...ibn,
          readAt: optimisticUpdate.readAt
        };
        break;
      }
      case "mark-all-inbox-notifications-as-read": {
        for (const id in computed.notificationsById) {
          const ibn = computed.notificationsById[id];
          if (ibn === void 0) {
            break;
          }
          computed.notificationsById[id] = {
            ...ibn,
            readAt: optimisticUpdate.readAt
          };
        }
        break;
      }
      case "delete-inbox-notification": {
        delete computed.notificationsById[optimisticUpdate.inboxNotificationId];
        break;
      }
      case "delete-all-inbox-notifications": {
        computed.notificationsById = {};
        break;
      }
      case "update-notification-settings": {
        const settings = computed.settingsByRoomId[optimisticUpdate.roomId];
        if (settings === void 0) {
          break;
        }
        computed.settingsByRoomId[optimisticUpdate.roomId] = {
          ...settings,
          ...optimisticUpdate.settings
        };
      }
    }
  }
  const cleanedNotifications = (
    // Sort so that the most recent notifications are first
    Object.values(computed.notificationsById).filter(
      (ibn) => ibn.kind === "thread" ? threadsDB.get(ibn.threadId) !== void 0 : true
    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())
  );
  return {
    cleanedNotifications,
    notificationsById: computed.notificationsById,
    settingsByRoomId: computed.settingsByRoomId,
    threadsDB,
    versionsByRoomId: state.versionsByRoomId
  };
}
function applyThreadDeltaUpdates(db, updates) {
  updates.newThreads.forEach((thread) => db.upsertIfNewer(thread));
  updates.deletedThreads.forEach(({ id, deletedAt }) => {
    const existing = db.getEvenIfDeleted(id);
    if (!existing) return;
    db.delete(id, deletedAt);
  });
}
function applyNotificationsUpdates(existingInboxNotifications, updates) {
  const updatedInboxNotifications = { ...existingInboxNotifications };
  updates.newInboxNotifications.forEach((notification) => {
    const existingNotification = updatedInboxNotifications[notification.id];
    if (existingNotification) {
      const result = compareInboxNotifications(
        existingNotification,
        notification
      );
      if (result === 1) return;
    }
    updatedInboxNotifications[notification.id] = notification;
  });
  updates.deletedNotifications.forEach(
    ({ id }) => delete updatedInboxNotifications[id]
  );
  return updatedInboxNotifications;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
    return 1;
  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
    return -1;
  }
  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
    return inboxNotificationA.readAt ? 1 : -1;
  }
  return 0;
}
function applyUpsertComment(thread, comment) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  if (comment.threadId !== thread.id) {
    console2.warn(
      `Comment ${comment.id} does not belong to thread ${thread.id}`
    );
    return thread;
  }
  const existingComment = thread.comments.find(
    (existingComment2) => existingComment2.id === comment.id
  );
  if (existingComment === void 0) {
    const updatedAt = new Date(
      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())
    );
    const updatedThread = {
      ...thread,
      updatedAt,
      comments: [...thread.comments, comment]
    };
    return updatedThread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
    const updatedComments = thread.comments.map(
      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2
    );
    const updatedThread = {
      ...thread,
      updatedAt: new Date(
        Math.max(
          thread.updatedAt.getTime(),
          comment.editedAt?.getTime() || comment.createdAt.getTime()
        )
      ),
      comments: updatedComments
    };
    return updatedThread;
  }
  return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      deletedAt,
      // We optimistically remove the comment body and attachments when marking it as deleted
      body: void 0,
      attachments: []
    } : comment
  );
  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {
    return {
      ...thread,
      deletedAt,
      updatedAt: deletedAt
    };
  }
  return {
    ...thread,
    updatedAt: deletedAt,
    comments: updatedComments
  };
}
function applyAddReaction(thread, commentId, reaction) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: upsertReaction(comment.reactions, reaction)
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: comment.reactions.map(
        (reaction) => reaction.emoji === emoji ? {
          ...reaction,
          users: reaction.users.filter((user) => user.id !== userId)
        } : reaction
      ).filter((reaction) => reaction.users.length > 0)
      // Remove reactions with no users left
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(removedAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function upsertReaction(reactions, reaction) {
  const existingReaction = reactions.find(
    (existingReaction2) => existingReaction2.emoji === reaction.emoji
  );
  if (existingReaction === void 0) {
    return [
      ...reactions,
      {
        emoji: reaction.emoji,
        createdAt: reaction.createdAt,
        users: [{ id: reaction.userId }]
      }
    ];
  }
  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {
    return reactions.map(
      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {
        ...existingReaction2,
        users: [...existingReaction2.users, { id: reaction.userId }]
      } : existingReaction2
    );
  }
  return reactions;
}

// src/liveblocks.tsx
var ClientContext = createContext2(null);
function missingUserError(userId) {
  return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
  return new Error(
    `resolveRoomsInfo didn't return anything for room '${roomId}'`
  );
}
function identity(x) {
  return x;
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
function selectUnreadInboxNotificationsCount(inboxNotifications) {
  let count = 0;
  for (const notification of inboxNotifications) {
    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {
      count++;
    }
  }
  return count;
}
function selectorFor_useUnreadInboxNotificationsCount(result) {
  if (!result.inboxNotifications) {
    return result;
  }
  return {
    isLoading: false,
    count: selectUnreadInboxNotificationsCount(result.inboxNotifications)
  };
}
function selectorFor_useUser(state, userId) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingUserError(userId)
    };
  }
  return {
    isLoading: false,
    user: state.data
  };
}
function selectorFor_useRoomInfo(state, roomId) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingRoomInfoError(roomId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function getOrCreateContextBundle(client) {
  let bundle = _bundles.get(client);
  if (!bundle) {
    bundle = makeLiveblocksContextBundle(client);
    _bundles.set(client, bundle);
  }
  return bundle;
}
function getUmbrellaStoreForClient(client) {
  let store = _umbrellaStores.get(client);
  if (!store) {
    store = new UmbrellaStore(client);
    _umbrellaStores.set(client, store);
  }
  return store;
}
function getLiveblocksExtrasForClient(client) {
  let extras = _extras.get(client);
  if (!extras) {
    extras = makeLiveblocksExtrasForClient(client);
    _extras.set(client, extras);
  }
  return extras;
}
function makeLiveblocksExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  const notificationsPoller = makePoller(
    async (signal) => {
      try {
        return await store.fetchNotificationsDeltaUpdate(signal);
      } catch (err) {
        console.warn(`Polling new inbox notifications failed: ${String(err)}`);
        throw err;
      }
    },
    config.NOTIFICATIONS_POLL_INTERVAL,
    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }
  );
  const userThreadsPoller = makePoller(
    async (signal) => {
      try {
        return await store.fetchUserThreadsDeltaUpdate(signal);
      } catch (err) {
        console.warn(`Polling new user threads failed: ${String(err)}`);
        throw err;
      }
    },
    config.USER_THREADS_POLL_INTERVAL,
    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }
  );
  return {
    store,
    notificationsPoller,
    userThreadsPoller
  };
}
function makeLiveblocksContextBundle(client) {
  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);
  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);
  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);
  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);
  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);
  function LiveblocksProvider2(props) {
    useEnsureNoLiveblocksProvider();
    return /* @__PURE__ */ React2.createElement(ClientContext.Provider, { value: client }, props.children);
  }
  const shared = createSharedContext(client);
  const bundle = {
    LiveblocksProvider: LiveblocksProvider2,
    useInboxNotifications: () => useInboxNotifications_withClient(client, identity, shallow3),
    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),
    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
    useDeleteInboxNotification: useDeleteInboxNotification2,
    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
    useInboxNotificationThread: useInboxNotificationThread2,
    useUserThreads_experimental,
    ...shared.classic,
    suspense: {
      LiveblocksProvider: LiveblocksProvider2,
      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),
      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),
      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
      useDeleteInboxNotification: useDeleteInboxNotification2,
      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
      useInboxNotificationThread: useInboxNotificationThread2,
      useUserThreads_experimental: useUserThreadsSuspense_experimental,
      ...shared.suspense
    }
  };
  return bundle;
}
function useInboxNotifications_withClient(client, selector, isEqual) {
  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);
  useEffect2(() => {
    void store.waitUntilNotificationsLoaded();
  });
  useEffect2(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    store.getInboxNotificationsLoadingState,
    store.getInboxNotificationsLoadingState,
    selector,
    isEqual
  );
}
function useInboxNotificationsSuspense_withClient(client) {
  const store = getLiveblocksExtrasForClient(client).store;
  use(store.waitUntilNotificationsLoaded());
  const result = useInboxNotifications_withClient(client, identity, shallow3);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useUnreadInboxNotificationsCount_withClient(client) {
  return useInboxNotifications_withClient(
    client,
    selectorFor_useUnreadInboxNotificationsCount,
    shallow3
  );
}
function useUnreadInboxNotificationsCountSuspense_withClient(client) {
  const store = getLiveblocksExtrasForClient(client).store;
  use(store.waitUntilNotificationsLoaded());
  const result = useUnreadInboxNotificationsCount_withClient(client);
  assert(!result.isLoading, "Did not expect loading");
  assert(!result.error, "Did not expect error");
  return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
  return useCallback2(
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const readAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId,
        readAt
      });
      client.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.updateInboxNotification(
            inboxNotificationId,
            optimisticUpdateId,
            (inboxNotification) => ({ ...inboxNotification, readAt })
          );
        },
        () => {
          store.removeOptimisticUpdate(optimisticUpdateId);
        }
      );
    },
    [client]
  );
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
  return useCallback2(() => {
    const { store } = getLiveblocksExtrasForClient(client);
    const readAt = /* @__PURE__ */ new Date();
    const optimisticUpdateId = store.addOptimisticUpdate({
      type: "mark-all-inbox-notifications-as-read",
      readAt
    });
    client.markAllInboxNotificationsAsRead().then(
      () => {
        store.updateAllInboxNotifications(
          optimisticUpdateId,
          (inboxNotification) => ({ ...inboxNotification, readAt })
        );
      },
      () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      }
    );
  }, [client]);
}
function useDeleteInboxNotification_withClient(client) {
  return useCallback2(
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const deletedAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "delete-inbox-notification",
        inboxNotificationId,
        deletedAt
      });
      client.deleteInboxNotification(inboxNotificationId).then(
        () => {
          store.deleteInboxNotification(
            inboxNotificationId,
            optimisticUpdateId
          );
        },
        () => {
          store.removeOptimisticUpdate(optimisticUpdateId);
        }
      );
    },
    [client]
  );
}
function useDeleteAllInboxNotifications_withClient(client) {
  return useCallback2(() => {
    const { store } = getLiveblocksExtrasForClient(client);
    const deletedAt = /* @__PURE__ */ new Date();
    const optimisticUpdateId = store.addOptimisticUpdate({
      type: "delete-all-inbox-notifications",
      deletedAt
    });
    client.deleteAllInboxNotifications().then(
      () => {
        store.deleteAllInboxNotifications(optimisticUpdateId);
      },
      () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      }
    );
  }, [client]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
  const { store } = getLiveblocksExtrasForClient(client);
  const getter = store.getFullState;
  const selector = useCallback2(
    (state) => {
      const inboxNotification = state.notificationsById[inboxNotificationId] ?? raise(`Inbox notification with ID "${inboxNotificationId}" not found`);
      if (inboxNotification.kind !== "thread") {
        raise(
          `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`
        );
      }
      const thread = state.threadsDB.get(inboxNotification.threadId) ?? raise(
        `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`
      );
      return thread;
    },
    [inboxNotificationId]
  );
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    // Re-evaluate if we need to update any time the notification changes over time
    getter,
    getter,
    selector
  );
}
function useUser_withClient(client, userId) {
  const usersStore = client[kInternal2].usersStore;
  const getUserState = useCallback2(
    () => usersStore.getState(userId),
    [usersStore, userId]
  );
  const selector = useCallback2(
    (state) => selectorFor_useUser(state, userId),
    [userId]
  );
  const result = useSyncExternalStoreWithSelector(
    usersStore.subscribe,
    getUserState,
    getUserState,
    selector,
    shallow3
  );
  useEffect2(() => {
    void usersStore.get(userId);
  }, [usersStore, userId, result]);
  return result;
}
function useUserSuspense_withClient(client, userId) {
  const usersStore = client[kInternal2].usersStore;
  const getUserState = useCallback2(
    () => usersStore.getState(userId),
    [usersStore, userId]
  );
  const userState = getUserState();
  if (!userState || userState.isLoading) {
    throw usersStore.get(userId);
  }
  if (userState.error) {
    throw userState.error;
  }
  if (!userState.data) {
    throw missingUserError(userId);
  }
  const state = useSyncExternalStore(
    usersStore.subscribe,
    getUserState,
    getUserState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    user: state.data,
    error: void 0
  };
}
function useRoomInfo_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal2].roomsInfoStore;
  const getRoomInfoState = useCallback2(
    () => roomsInfoStore.getState(roomId),
    [roomsInfoStore, roomId]
  );
  const selector = useCallback2(
    (state) => selectorFor_useRoomInfo(state, roomId),
    [roomId]
  );
  const result = useSyncExternalStoreWithSelector(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState,
    selector,
    shallow3
  );
  useEffect2(() => {
    void roomsInfoStore.get(roomId);
  }, [roomsInfoStore, roomId, result]);
  return result;
}
function useRoomInfoSuspense_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal2].roomsInfoStore;
  const getRoomInfoState = useCallback2(
    () => roomsInfoStore.getState(roomId),
    [roomsInfoStore, roomId]
  );
  const roomInfoState = getRoomInfoState();
  if (!roomInfoState || roomInfoState.isLoading) {
    throw roomsInfoStore.get(roomId);
  }
  if (roomInfoState.error) {
    throw roomInfoState.error;
  }
  if (!roomInfoState.data) {
    throw missingRoomInfoError(roomId);
  }
  const state = useSyncExternalStore(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  assert(state.data !== void 0, "Unexpected missing room info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function createSharedContext(client) {
  const useClient2 = () => client;
  return {
    classic: {
      useClient: useClient2,
      useUser: (userId) => useUser_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),
      useIsInsideRoom
    },
    suspense: {
      useClient: useClient2,
      useUser: (userId) => useUserSuspense_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),
      useIsInsideRoom
    }
  };
}
function useEnsureNoLiveblocksProvider(options) {
  const existing = useClientOrNull();
  if (!options?.allowNesting && existing !== null) {
    throw new Error(
      "You cannot nest multiple LiveblocksProvider instances in the same React tree."
    );
  }
}
function useClientOrNull() {
  return useContext2(ClientContext);
}
function useClient() {
  return useClientOrNull() ?? raise("LiveblocksProvider is missing from the React tree.");
}
function LiveblocksProviderWithClient(props) {
  useEnsureNoLiveblocksProvider(props);
  return /* @__PURE__ */ React2.createElement(ClientContext.Provider, { value: props.client }, props.children);
}
function LiveblocksProvider(props) {
  const { children, ...o } = props;
  const options = {
    publicApiKey: useInitial(o.publicApiKey),
    throttle: useInitial(o.throttle),
    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
    polyfills: useInitial(o.polyfills),
    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),
    unstable_streamData: useInitial(o.unstable_streamData),
    authEndpoint: useInitialUnlessFunction(o.authEndpoint),
    resolveMentionSuggestions: useInitialUnlessFunction(
      o.resolveMentionSuggestions
    ),
    resolveUsers: useInitialUnlessFunction(o.resolveUsers),
    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
    baseUrl: useInitial(
      // @ts-expect-error - Hidden config options
      o.baseUrl
    ),
    enableDebugLogging: useInitial(
      // @ts-expect-error - Hidden config options
      o.enableDebugLogging
    )
  };
  const client = useMemo(() => createClient(options), []);
  return /* @__PURE__ */ React2.createElement(LiveblocksProviderWithClient, { client }, children);
}
function createLiveblocksContext(client) {
  return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {
  query: {
    metadata: {}
  }
}) {
  const client = useClient();
  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);
  useEffect2(
    () => {
      void store.waitUntilUserThreadsLoaded(options.query);
    }
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  useEffect2(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const getter = useCallback2(
    () => store.getUserThreadsLoadingState(options.query),
    [store, options.query]
  );
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    getter,
    getter,
    identity,
    shallow2
    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!
  );
}
function useUserThreadsSuspense_experimental(options = {
  query: {
    metadata: {}
  }
}) {
  const client = useClient();
  const { store } = getLiveblocksExtrasForClient(client);
  use(store.waitUntilUserThreadsLoaded(options.query));
  const result = useUserThreads_experimental(options);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useInboxNotifications() {
  return useInboxNotifications_withClient(useClient(), identity, shallow3);
}
function useInboxNotificationsSuspense() {
  return useInboxNotificationsSuspense_withClient(useClient());
}
function useInboxNotificationThread(inboxNotificationId) {
  return useInboxNotificationThread_withClient(
    useClient(),
    inboxNotificationId
  );
}
function useMarkAllInboxNotificationsAsRead() {
  return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
  return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
  return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
  return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount() {
  return useUnreadInboxNotificationsCount_withClient(useClient());
}
function useUnreadInboxNotificationsCountSuspense() {
  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());
}
function useUser(userId) {
  const client = useClient();
  return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
  const client = useClient();
  return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
  return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
  return useRoomInfoSuspense_withClient(useClient(), roomId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;

// src/types/errors.ts
var CreateThreadError = class extends Error {
  constructor(cause, context) {
    super("Create thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateThreadError";
  }
};
var DeleteThreadError = class extends Error {
  constructor(cause, context) {
    super("Delete thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteThreadError";
  }
};
var EditThreadMetadataError = class extends Error {
  constructor(cause, context) {
    super("Edit thread metadata failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditThreadMetadataError";
  }
};
var MarkThreadAsResolvedError = class extends Error {
  constructor(cause, context) {
    super("Mark thread as resolved failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkThreadAsResolvedError";
  }
};
var MarkThreadAsUnresolvedError = class extends Error {
  constructor(cause, context) {
    super("Mark thread as unresolved failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkThreadAsUnresolvedError";
  }
};
var CreateCommentError = class extends Error {
  constructor(cause, context) {
    super("Create comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateCommentError";
  }
};
var EditCommentError = class extends Error {
  constructor(cause, context) {
    super("Edit comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditCommentError";
  }
};
var DeleteCommentError = class extends Error {
  constructor(cause, context) {
    super("Delete comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteCommentError";
  }
};
var AddReactionError = class extends Error {
  constructor(cause, context) {
    super("Add reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "AddReactionError";
  }
};
var RemoveReactionError = class extends Error {
  constructor(cause, context) {
    super("Remove reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "RemoveReactionError";
  }
};
var MarkInboxNotificationAsReadError = class extends Error {
  constructor(cause, context) {
    super("Mark inbox notification as read failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkInboxNotificationAsReadError";
  }
};
var UpdateNotificationSettingsError = class extends Error {
  constructor(cause, context) {
    super("Update notification settings failed.");
    this.cause = cause;
    this.context = context;
    this.name = "UpdateNotificationSettingsError";
  }
};

// src/room.tsx
import { shallow as shallow4 } from "@liveblocks/client";
import {
  assert as assert2,
  console as console3,
  createCommentId,
  createThreadId,
  deprecateIf,
  errorIf,
  HttpError as HttpError2,
  kInternal as kInternal3,
  makeEventSource as makeEventSource2,
  makePoller as makePoller2,
  ServerMsgCode
} from "@liveblocks/core";
import * as React4 from "react";
import { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from "use-sync-external-store/shim/with-selector.js";

// src/use-scroll-to-comment-on-load-effect.ts
import * as React3 from "react";
function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
  if (shouldScrollOnLoad === false) return;
  if (!state.threads) return;
  const isWindowDefined = typeof window !== "undefined";
  if (!isWindowDefined) return;
  const hash = window.location.hash;
  const commentId = hash.slice(1);
  if (!commentId.startsWith("cm_")) return;
  const comment = document.getElementById(commentId);
  if (comment === null) return;
  const comments = state.threads.flatMap((thread) => thread.comments);
  const isCommentInThreads = comments.some(
    (comment2) => comment2.id === commentId
  );
  if (!isCommentInThreads) return;
  comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
  React3.useEffect(
    () => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [state.isLoading]
  );
}

// src/room.tsx
var SMOOTH_DELAY = 1e3;
var noop3 = () => {
};
var identity2 = (x) => x;
var missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(
  roomId
)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;
var superfluous_unstable_batchedUpdates = "You don\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\u2019re on React 18+ already.";
function useSyncExternalStore2(s, gs, gss) {
  return useSyncExternalStoreWithSelector2(s, gs, gss, identity2);
}
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function selectorFor_useOthersConnectionIds(others) {
  return others.map((user) => user.connectionId);
}
function makeMutationContext(room) {
  const cannotUseUntil = "This mutation cannot be used until";
  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
  const needsStorage = `${cannotUseUntil} storage has been loaded`;
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(needsStorage);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(needsPresence);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(needsPresence);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
function getCurrentUserId(room) {
  const self = room.getSelf();
  if (self === null || self.id === void 0) {
    return "anonymous";
  } else {
    return self.id;
  }
}
function handleApiError(err) {
  const message = `Request failed with status ${err.status}: ${err.message}`;
  if (err.details?.error === "FORBIDDEN") {
    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join("\n");
    console3.error(detailedMessage);
  }
  return new Error(message);
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
  let bundle = _bundles2.get(client);
  if (!bundle) {
    bundle = makeRoomContextBundle(client);
    _bundles2.set(client, bundle);
  }
  return bundle;
}
function getRoomExtrasForClient(client) {
  let extras = _extras2.get(client);
  if (!extras) {
    extras = makeRoomExtrasForClient(client);
    _extras2.set(client, extras);
  }
  return extras;
}
function makeRoomExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  const commentsErrorEventSource = makeEventSource2();
  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {
    store.removeOptimisticUpdate(optimisticUpdateId);
    if (innerError instanceof HttpError2) {
      const error = handleApiError(innerError);
      commentsErrorEventSource.notify(createPublicError(error));
      return;
    }
    if (innerError instanceof HttpError2) {
      handleApiError(innerError);
      return;
    }
    throw innerError;
  }
  const threadsPollersByRoomId = /* @__PURE__ */ new Map();
  const versionsPollersByRoomId = /* @__PURE__ */ new Map();
  const roomNotificationSettingsPollersByRoomId = /* @__PURE__ */ new Map();
  function getOrCreateThreadsPollerForRoomId(roomId) {
    let poller = threadsPollersByRoomId.get(roomId);
    if (!poller) {
      poller = makePoller2(
        async (signal) => {
          try {
            return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
          } catch (err) {
            console3.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);
            throw err;
          }
        },
        config.ROOM_THREADS_POLL_INTERVAL,
        { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }
      );
      threadsPollersByRoomId.set(roomId, poller);
    }
    return poller;
  }
  function getOrCreateVersionsPollerForRoomId(roomId) {
    let poller = versionsPollersByRoomId.get(roomId);
    if (!poller) {
      poller = makePoller2(
        async (signal) => {
          try {
            return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
          } catch (err) {
            console3.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);
            throw err;
          }
        },
        config.HISTORY_VERSIONS_POLL_INTERVAL,
        { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }
      );
      versionsPollersByRoomId.set(roomId, poller);
    }
    return poller;
  }
  function getOrCreateNotificationsSettingsPollerForRoomId(roomId) {
    let poller = roomNotificationSettingsPollersByRoomId.get(roomId);
    if (!poller) {
      poller = makePoller2(
        async (signal) => {
          try {
            return await store.refreshRoomNotificationSettings(roomId, signal);
          } catch (err) {
            console3.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);
            throw err;
          }
        },
        config.NOTIFICATION_SETTINGS_POLL_INTERVAL,
        { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }
      );
      roomNotificationSettingsPollersByRoomId.set(roomId, poller);
    }
    return poller;
  }
  return {
    store,
    commentsErrorEventSource: commentsErrorEventSource.observable,
    onMutationFailure,
    getOrCreateThreadsPollerForRoomId,
    getOrCreateVersionsPollerForRoomId,
    getOrCreateNotificationsSettingsPollerForRoomId
  };
}
function makeRoomContextBundle(client) {
  function RoomProvider_withImplicitLiveblocksProvider(props) {
    return /* @__PURE__ */ React4.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ React4.createElement(RoomProvider, { ...props }));
  }
  const shared = createSharedContext(client);
  const bundle = {
    RoomContext,
    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
    useRoom,
    useStatus,
    useStorageStatus,
    useBatch,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useErrorListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useDeleteThread,
    useEditThreadMetadata,
    useMarkThreadAsResolved,
    useMarkThreadAsUnresolved,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useAttachmentUrl,
    useHistoryVersions,
    useHistoryVersionData,
    useRoomNotificationSettings,
    useUpdateRoomNotificationSettings,
    ...shared.classic,
    suspense: {
      RoomContext,
      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
      useRoom,
      useStatus,
      useStorageStatus: useStorageStatusSuspense,
      useBatch,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useErrorListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useDeleteThread,
      useEditThreadMetadata,
      useMarkThreadAsResolved,
      useMarkThreadAsUnresolved,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      useAttachmentUrl: useAttachmentUrlSuspense,
      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
      useHistoryVersions: useHistoryVersionsSuspense,
      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,
      useUpdateRoomNotificationSettings,
      ...shared.suspense
    },
    useCommentsErrorListener
  };
  return Object.defineProperty(bundle, kInternal3, {
    enumerable: false
  });
}
function RoomProvider(props) {
  const client = useClient();
  const [cache] = React4.useState(
    () => /* @__PURE__ */ new Map()
  );
  const stableEnterRoom = React4.useCallback(
    (roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) return cached;
      const rv = client.enterRoom(roomId, options);
      const origLeave = rv.leave;
      rv.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, rv);
      return rv;
    },
    [client, cache]
  );
  return /* @__PURE__ */ React4.createElement(
    RoomProviderInner,
    {
      ...props,
      stableEnterRoom
    }
  );
}
function RoomProviderInner(props) {
  const client = useClient();
  const { id: roomId, stableEnterRoom } = props;
  if (process.env.NODE_ENV !== "production") {
    if (!roomId) {
      throw new Error(
        "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
      );
    }
    if (!isString(roomId)) {
      throw new Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(React4.version) || 1;
    const oldReactVersion = majorReactVersion < 18;
    errorIf(
      oldReactVersion && props.unstable_batchedUpdates === void 0,
      missing_unstable_batchedUpdates(majorReactVersion, roomId)
    );
    deprecateIf(
      !oldReactVersion && props.unstable_batchedUpdates !== void 0,
      superfluous_unstable_batchedUpdates
    );
  }
  const frozenProps = useInitial({
    initialPresence: props.initialPresence,
    initialStorage: props.initialStorage,
    unstable_batchedUpdates: props.unstable_batchedUpdates,
    autoConnect: props.autoConnect ?? typeof window !== "undefined"
  });
  const [{ room }, setRoomLeavePair] = React4.useState(
    () => stableEnterRoom(roomId, {
      ...frozenProps,
      autoConnect: false
      // Deliberately using false here on the first render, see below
    })
  );
  React4.useEffect(() => {
    const { store } = getRoomExtrasForClient(client);
    async function handleCommentEvent(message) {
      if (message.type === ServerMsgCode.THREAD_DELETED) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const info = await room.getThread(message.threadId);
      if (!info.thread) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const { thread, inboxNotification } = info;
      const existingThread = store.getFullState().threadsDB.getEvenIfDeleted(message.threadId);
      switch (message.type) {
        case ServerMsgCode.COMMENT_EDITED:
        case ServerMsgCode.THREAD_METADATA_UPDATED:
        case ServerMsgCode.THREAD_UPDATED:
        case ServerMsgCode.COMMENT_REACTION_ADDED:
        case ServerMsgCode.COMMENT_REACTION_REMOVED:
        case ServerMsgCode.COMMENT_DELETED:
          if (!existingThread) break;
          store.updateThreadAndNotification(thread, inboxNotification);
          break;
        case ServerMsgCode.COMMENT_CREATED:
          store.updateThreadAndNotification(thread, inboxNotification);
          break;
        default:
          break;
      }
    }
    return room.events.comments.subscribe(
      (message) => void handleCommentEvent(message)
    );
  }, [client, room]);
  React4.useEffect(() => {
    const pair = stableEnterRoom(roomId, frozenProps);
    setRoomLeavePair(pair);
    const { room: room2, leave } = pair;
    if (frozenProps.autoConnect) {
      room2.connect();
    }
    return () => {
      leave();
    };
  }, [roomId, frozenProps, stableEnterRoom]);
  return /* @__PURE__ */ React4.createElement(RoomContext.Provider, { value: room }, props.children);
}
function useRoom() {
  const room = useRoomOrNull();
  if (room === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return room;
}
function useStatus() {
  const room = useRoom();
  const subscribe = room.events.status.subscribe;
  const getSnapshot = room.getStatus;
  const getServerSnapshot = room.getStatus;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatus(options) {
  const smooth = useInitial(options?.smooth ?? false);
  if (smooth) {
    return useStorageStatusSmooth();
  } else {
    return useStorageStatusImmediate();
  }
}
function useStorageStatusImmediate() {
  const room = useRoom();
  const subscribe = room.events.storageStatus.subscribe;
  const getSnapshot = room.getStorageStatus;
  const getServerSnapshot = room.getStorageStatus;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatusSmooth() {
  const room = useRoom();
  const [status, setStatus] = React4.useState(room.getStorageStatus);
  const oldStatus = useLatest(room.getStorageStatus());
  React4.useEffect(() => {
    let timeoutId;
    const unsub = room.events.storageStatus.subscribe((newStatus) => {
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [room, oldStatus]);
  return status;
}
function useBatch() {
  return useRoom().batch;
}
function useBroadcastEvent() {
  const room = useRoom();
  return React4.useCallback(
    (event, options = { shouldQueueEventIfNotReady: false }) => {
      room.broadcastEvent(event, options);
    },
    [room]
  );
}
function useOthersListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(
    () => room.events.others.subscribe((event) => savedCallback.current(event)),
    [room, savedCallback]
  );
}
function useLostConnectionListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(
    () => room.events.lostConnection.subscribe(
      (event) => savedCallback.current(event)
    ),
    [room, savedCallback]
  );
}
function useErrorListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(
    () => room.events.error.subscribe((e) => savedCallback.current(e)),
    [room, savedCallback]
  );
}
function useEventListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(() => {
    const listener = (eventData) => {
      savedCallback.current(eventData);
    };
    return room.events.customEvent.subscribe(listener);
  }, [room, savedCallback]);
}
function useHistory() {
  return useRoom().history;
}
function useUndo() {
  return useHistory().undo;
}
function useRedo() {
  return useHistory().redo;
}
function useCanUndo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canUndo = room.history.canUndo;
  return useSyncExternalStore2(subscribe, canUndo, canUndo);
}
function useCanRedo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canRedo = room.history.canRedo;
  return useSyncExternalStore2(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.self.subscribe;
  const getSnapshot = room.getSelf;
  const selector = maybeSelector ?? identity2;
  const wrappedSelector = React4.useCallback(
    (me) => me !== null ? selector(me) : null,
    [selector]
  );
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector2(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMyPresence() {
  const room = useRoom();
  const subscribe = room.events.myPresence.subscribe;
  const getSnapshot = room.getPresence;
  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);
  const setPresence = room.updatePresence;
  return [presence, setPresence];
}
function useUpdateMyPresence() {
  return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.others.subscribe;
  const getSnapshot = room.getOthers;
  const getServerSnapshot = alwaysEmptyList;
  return useSyncExternalStoreWithSelector2(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    selector ?? identity2,
    isEqual
  );
}
function useOthersMapped(itemSelector, itemIsEqual) {
  const wrappedSelector = React4.useCallback(
    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),
    [itemSelector]
  );
  const wrappedIsEqual = React4.useCallback(
    (a, b) => {
      const eq = itemIsEqual ?? Object.is;
      return a.length === b.length && a.every((atuple, index) => {
        const btuple = b[index];
        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
      });
    },
    [itemIsEqual]
  );
  return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
  return useOthers(selectorFor_useOthersConnectionIds, shallow4);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
  const wrappedSelector = React4.useCallback(
    (others) => {
      const other2 = others.find((other3) => other3.connectionId === connectionId);
      return other2 !== void 0 ? selector(other2) : NOT_FOUND;
    },
    [connectionId, selector]
  );
  const wrappedIsEqual = React4.useCallback(
    (prev, curr) => {
      if (prev === NOT_FOUND || curr === NOT_FOUND) {
        return prev === curr;
      }
      const eq = isEqual ?? Object.is;
      return eq(prev, curr);
    },
    [isEqual]
  );
  const other = useOthers(wrappedSelector, wrappedIsEqual);
  if (other === NOT_FOUND) {
    throw new Error(
      `No such other user with connection id ${connectionId} exists`
    );
  }
  return other;
}
function useMutableStorageRoot() {
  const room = useRoom();
  const subscribe = room.events.storageDidLoad.subscribeOnce;
  const getSnapshot = room.getStorageSnapshot;
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
  return [useMutableStorageRoot()];
}
function useStorage(selector, isEqual) {
  const room = useRoom();
  const rootOrNull = useMutableStorageRoot();
  const wrappedSelector = React4.useCallback(
    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
    [selector]
  );
  const subscribe = React4.useCallback(
    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,
    [room, rootOrNull]
  );
  const getSnapshot = React4.useCallback(() => {
    if (rootOrNull === null) {
      return null;
    } else {
      const root = rootOrNull;
      const imm = root.toImmutable();
      return imm;
    }
  }, [rootOrNull]);
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector2(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMutation(callback, deps) {
  const room = useRoom();
  return React4.useMemo(
    () => {
      return (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        room.batch(
          () => (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            callback(
              makeMutationContext(room),
              ...args
            )
          )
        )
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [room, ...deps]
  );
}
function useThreads(options = {
  query: { metadata: {} }
}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateThreadsPollerForRoomId(room.id);
  React4.useEffect(
    () => {
      void store.waitUntilRoomThreadsLoaded(room.id, options.query);
    }
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  React4.useEffect(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  const getter = React4.useCallback(
    () => store.getRoomThreadsLoadingState(room.id, options.query),
    [store, room.id, options.query]
  );
  const state = useSyncExternalStoreWithSelector2(
    store.subscribe,
    getter,
    getter,
    identity2,
    shallow2
    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, state);
  return state;
}
function useCommentsErrorListener(callback) {
  const client = useClient();
  const savedCallback = useLatest(callback);
  const { commentsErrorEventSource } = getRoomExtrasForClient(client);
  React4.useEffect(() => {
    return commentsErrorEventSource.subscribe(savedCallback.current);
  }, [savedCallback, commentsErrorEventSource]);
}
function useCreateThread() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (options) => {
      const body = options.body;
      const metadata = options.metadata ?? {};
      const attachments = options.attachments;
      const threadId = createThreadId();
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const newComment = {
        id: commentId,
        threadId,
        roomId: room.id,
        createdAt,
        type: "comment",
        userId: getCurrentUserId(room),
        body,
        reactions: [],
        attachments: attachments ?? []
      };
      const newThread = {
        id: threadId,
        type: "thread",
        createdAt,
        updatedAt: createdAt,
        roomId: room.id,
        metadata,
        comments: [newComment],
        resolved: false
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "create-thread",
        thread: newThread,
        roomId: room.id
      });
      const attachmentIds = attachments?.map((attachment) => attachment.id);
      room.createThread({ threadId, commentId, body, metadata, attachmentIds }).then(
        (thread) => {
          store.createThread(optimisticUpdateId, thread);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new CreateThreadError(err2, {
            roomId: room.id,
            threadId,
            commentId,
            body,
            metadata
          })
        )
      );
      return newThread;
    },
    [client, room]
  );
}
function useDeleteThread() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const userId = getCurrentUserId(room);
      const existing = store.getFullState().threadsDB.get(threadId);
      if (existing?.comments?.[0]?.userId !== userId) {
        throw new Error("Only the thread creator can delete the thread");
      }
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "delete-thread",
        roomId: room.id,
        threadId,
        deletedAt: /* @__PURE__ */ new Date()
      });
      room.deleteThread(threadId).then(
        () => {
          store.deleteThread(threadId, optimisticUpdateId);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })
        )
      );
    },
    [client, room]
  );
}
function useEditThreadMetadata() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (options) => {
      if (!options.metadata) {
        return;
      }
      const threadId = options.threadId;
      const metadata = options.metadata;
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "edit-thread-metadata",
        metadata,
        threadId,
        updatedAt
      });
      room.editThreadMetadata({ threadId, metadata }).then(
        (metadata2) => (
          // Replace the optimistic update by the real thing
          store.patchThread(
            threadId,
            optimisticUpdateId,
            { metadata: metadata2 },
            updatedAt
          )
        ),
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new EditThreadMetadataError(error, {
            roomId: room.id,
            threadId,
            metadata
          })
        )
      );
    },
    [client, room]
  );
}
function useCreateComment() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, body, attachments }) => {
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const comment = {
        id: commentId,
        threadId,
        roomId: room.id,
        type: "comment",
        createdAt,
        userId: getCurrentUserId(room),
        body,
        reactions: [],
        attachments: attachments ?? []
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "create-comment",
        comment
      });
      const attachmentIds = attachments?.map((attachment) => attachment.id);
      room.createComment({ threadId, commentId, body, attachmentIds }).then(
        (newComment) => {
          store.createComment(newComment, optimisticUpdateId);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new CreateCommentError(err2, {
            roomId: room.id,
            threadId,
            commentId,
            body
          })
        )
      );
      return comment;
    },
    [client, room]
  );
}
function useEditComment() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId, body, attachments }) => {
      const editedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const existing = store.getFullState().threadsDB.getEvenIfDeleted(threadId);
      if (existing === void 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
        );
        return;
      }
      const comment = existing.comments.find(
        (comment2) => comment2.id === commentId
      );
      if (comment === void 0 || comment.deletedAt !== void 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
        );
        return;
      }
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "edit-comment",
        comment: {
          ...comment,
          editedAt,
          body,
          attachments: attachments ?? []
        }
      });
      const attachmentIds = attachments?.map((attachment) => attachment.id);
      room.editComment({ threadId, commentId, body, attachmentIds }).then(
        (editedComment) => {
          store.editComment(threadId, optimisticUpdateId, editedComment);
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new EditCommentError(error, {
            roomId: room.id,
            threadId,
            commentId,
            body
          })
        )
      );
    },
    [client, room]
  );
}
function useDeleteComment() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId }) => {
      const deletedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "delete-comment",
        threadId,
        commentId,
        deletedAt,
        roomId: room.id
      });
      room.deleteComment({ threadId, commentId }).then(
        () => {
          store.deleteComment(
            threadId,
            optimisticUpdateId,
            commentId,
            deletedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new DeleteCommentError(error, {
            roomId: room.id,
            threadId,
            commentId
          })
        )
      );
    },
    [client, room]
  );
}
function useAddReaction() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId, emoji }) => {
      const createdAt = /* @__PURE__ */ new Date();
      const userId = getCurrentUserId(room);
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "add-reaction",
        threadId,
        commentId,
        reaction: {
          emoji,
          userId,
          createdAt
        }
      });
      room.addReaction({ threadId, commentId, emoji }).then(
        (addedReaction) => {
          store.addReaction(
            threadId,
            optimisticUpdateId,
            commentId,
            addedReaction,
            createdAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new AddReactionError(error, {
            roomId: room.id,
            threadId,
            commentId,
            emoji
          })
        )
      );
    },
    [client, room]
  );
}
function useRemoveReaction() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId, emoji }) => {
      const userId = getCurrentUserId(room);
      const removedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "remove-reaction",
        threadId,
        commentId,
        emoji,
        userId,
        removedAt
      });
      room.removeReaction({ threadId, commentId, emoji }).then(
        () => {
          store.removeReaction(
            threadId,
            optimisticUpdateId,
            commentId,
            emoji,
            userId,
            removedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new RemoveReactionError(error, {
            roomId: room.id,
            threadId,
            commentId,
            emoji
          })
        )
      );
    },
    [client, room]
  );
}
function useMarkThreadAsRead() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const inboxNotification = Object.values(
        store.getFullState().notificationsById
      ).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      if (!inboxNotification) return;
      const now = /* @__PURE__ */ new Date();
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId: inboxNotification.id,
        readAt: now
      });
      room.markInboxNotificationAsRead(inboxNotification.id).then(
        () => {
          store.updateInboxNotification(
            inboxNotification.id,
            optimisticUpdateId,
            (inboxNotification2) => ({ ...inboxNotification2, readAt: now })
          );
        },
        (err) => {
          onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new MarkInboxNotificationAsReadError(error, {
              inboxNotificationId: inboxNotification.id
            })
          );
          return;
        }
      );
    },
    [client, room]
  );
}
function useMarkThreadAsResolved() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-thread-as-resolved",
        threadId,
        updatedAt
      });
      room.markThreadAsResolved(threadId).then(
        () => {
          store.patchThread(
            threadId,
            optimisticUpdateId,
            { resolved: true },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new MarkThreadAsResolvedError(error, {
            roomId: room.id,
            threadId
          })
        )
      );
    },
    [client, room]
  );
}
function useMarkThreadAsUnresolved() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "mark-thread-as-unresolved",
        threadId,
        updatedAt
      });
      room.markThreadAsUnresolved(threadId).then(
        () => {
          store.patchThread(
            threadId,
            optimisticUpdateId,
            { resolved: false },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new MarkThreadAsUnresolvedError(error, {
            roomId: room.id,
            threadId
          })
        )
      );
    },
    [client, room]
  );
}
function useThreadSubscription(threadId) {
  const client = useClient();
  const { store } = getRoomExtrasForClient(client);
  const selector = React4.useCallback(
    (state) => {
      const notification = state.cleanedNotifications.find(
        (inboxNotification) => inboxNotification.kind === "thread" && inboxNotification.threadId === threadId
      );
      const thread = state.threadsDB.get(threadId);
      if (notification === void 0 || thread === void 0) {
        return { status: "not-subscribed" };
      }
      return {
        status: "subscribed",
        unreadSince: notification.readAt
      };
    },
    [threadId]
  );
  return useSyncExternalStoreWithSelector2(
    store.subscribe,
    store.getFullState,
    store.getFullState,
    selector
  );
}
function useRoomNotificationSettings() {
  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);
  React4.useEffect(
    () => {
      void store.waitUntilRoomNotificationSettingsLoaded(room.id);
    }
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  React4.useEffect(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const getter = React4.useCallback(
    () => store.getNotificationSettingsLoadingState(room.id),
    [store, room.id]
  );
  const settings = useSyncExternalStoreWithSelector2(
    store.subscribe,
    getter,
    getter,
    identity2,
    shallow2
  );
  return React4.useMemo(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useRoomNotificationSettingsSuspense() {
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  const room = useRoom();
  use(store.waitUntilRoomNotificationSettingsLoaded(room.id));
  const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();
  assert2(!settings.error, "Did not expect error");
  assert2(!settings.isLoading, "Did not expect loading");
  return React4.useMemo(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useHistoryVersionData(versionId) {
  const [state, setState] = React4.useState({
    isLoading: true
  });
  const room = useRoom();
  React4.useEffect(() => {
    setState({ isLoading: true });
    const load = async () => {
      try {
        const response = await room[kInternal3].getTextVersion(versionId);
        const buffer = await response.arrayBuffer();
        const data = new Uint8Array(buffer);
        setState({
          isLoading: false,
          data
        });
      } catch (error) {
        setState({
          isLoading: false,
          error: error instanceof Error ? error : new Error(
            "An unknown error occurred while loading this version"
          )
        });
      }
    };
    void load();
  }, [room, versionId]);
  return state;
}
function useHistoryVersions() {
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateVersionsPollerForRoomId(room.id);
  React4.useEffect(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  const getter = React4.useCallback(
    () => store.getRoomVersionsLoadingState(room.id),
    [store, room.id]
  );
  React4.useEffect(
    () => {
      void store.waitUntilRoomVersionsLoaded(room.id);
    }
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  const state = useSyncExternalStoreWithSelector2(
    store.subscribe,
    getter,
    getter,
    identity2,
    shallow2
  );
  return state;
}
function useHistoryVersionsSuspense() {
  const client = useClient();
  const room = useRoom();
  const store = getRoomExtrasForClient(client).store;
  use(store.waitUntilRoomVersionsLoaded(room.id));
  const result = useHistoryVersions();
  assert2(!result.error, "Did not expect error");
  assert2(!result.isLoading, "Did not expect loading");
  return result;
}
function useUpdateRoomNotificationSettings() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (settings) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticUpdateId = store.addOptimisticUpdate({
        type: "update-notification-settings",
        roomId: room.id,
        settings
      });
      room.updateNotificationSettings(settings).then(
        (settings2) => {
          store.updateRoomNotificationSettings_confirmOptimisticUpdate(
            room.id,
            optimisticUpdateId,
            settings2
          );
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new UpdateNotificationSettingsError(error, {
            roomId: room.id
          })
        )
      );
    },
    [client, room]
  );
}
function ensureNotServerSide() {
  if (typeof window === "undefined") {
    throw new Error(
      "You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr"
    );
  }
}
function useSuspendUntilPresenceReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useSelf(
    selector,
    isEqual
  );
}
function useOthersSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOthers(
    selector,
    isEqual
  );
}
function useOthersConnectionIdsSuspense() {
  useSuspendUntilPresenceReady();
  return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
  useSuspendUntilPresenceReady();
  return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
  useSuspendUntilStorageReady();
  return useStorage(
    selector,
    isEqual
  );
}
function useStorageStatusSuspense(options) {
  useSuspendUntilStorageReady();
  return useStorageStatus(options);
}
function useThreadsSuspense(options = {
  query: { metadata: {} }
}) {
  const client = useClient();
  const room = useRoom();
  const { store } = getRoomExtrasForClient(client);
  use(store.waitUntilRoomThreadsLoaded(room.id, options.query));
  const result = useThreads(options);
  assert2(!result.error, "Did not expect error");
  assert2(!result.isLoading, "Did not expect loading");
  return result;
}
function selectorFor_useAttachmentUrl(state) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  assert2(state.data !== void 0, "Unexpected missing attachment URL");
  return {
    isLoading: false,
    url: state.data
  };
}
function useAttachmentUrl(attachmentId) {
  const room = useRoom();
  const { attachmentUrlsStore } = room[kInternal3];
  const getAttachmentUrlState = React4.useCallback(
    () => attachmentUrlsStore.getState(attachmentId),
    [attachmentUrlsStore, attachmentId]
  );
  React4.useEffect(() => {
    void attachmentUrlsStore.get(attachmentId);
  }, [attachmentUrlsStore, attachmentId]);
  return useSyncExternalStoreWithSelector2(
    attachmentUrlsStore.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState,
    selectorFor_useAttachmentUrl,
    shallow4
  );
}
function useAttachmentUrlSuspense(attachmentId) {
  const room = useRoom();
  const { attachmentUrlsStore } = room[kInternal3];
  const getAttachmentUrlState = React4.useCallback(
    () => attachmentUrlsStore.getState(attachmentId),
    [attachmentUrlsStore, attachmentId]
  );
  const attachmentUrlState = getAttachmentUrlState();
  if (!attachmentUrlState || attachmentUrlState.isLoading) {
    throw attachmentUrlsStore.get(attachmentId);
  }
  if (attachmentUrlState.error) {
    throw attachmentUrlState.error;
  }
  const state = useSyncExternalStore2(
    attachmentUrlsStore.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState
  );
  assert2(state !== void 0, "Unexpected missing state");
  assert2(!state.isLoading, "Unexpected loading state");
  assert2(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    url: state.data,
    error: void 0
  };
}
function createRoomContext(client) {
  return getOrCreateRoomContextBundle(client);
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useThreadsSuspense = useThreadsSuspense;
var _useRoomNotificationSettings = useRoomNotificationSettings;
var _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;
var _useHistoryVersions = useHistoryVersions;
var _useHistoryVersionsSuspense = useHistoryVersionsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
  return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
  return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
  return useSelf(...args);
}
function _useSelfSuspense(...args) {
  return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;

export {
  RoomContext,
  ClientContext,
  getUmbrellaStoreForClient,
  useClient,
  LiveblocksProvider,
  createLiveblocksContext,
  useInboxNotifications,
  useInboxNotificationsSuspense,
  useMarkAllInboxNotificationsAsRead,
  useMarkInboxNotificationAsRead,
  useDeleteAllInboxNotifications,
  useDeleteInboxNotification,
  useUnreadInboxNotificationsCount,
  useUnreadInboxNotificationsCountSuspense,
  useRoomInfo,
  useRoomInfoSuspense,
  _useInboxNotificationThread,
  _useUser,
  _useUserSuspense,
  _useUserThreads_experimental,
  _useUserThreadsSuspense_experimental,
  CreateThreadError,
  useStatus,
  useStorageStatus,
  useBatch,
  useLostConnectionListener,
  useErrorListener,
  useHistory,
  useUndo,
  useRedo,
  useCanUndo,
  useCanRedo,
  useOthersConnectionIds,
  useCommentsErrorListener,
  useCreateComment,
  useEditComment,
  useDeleteComment,
  useRemoveReaction,
  useMarkThreadAsRead,
  useMarkThreadAsResolved,
  useMarkThreadAsUnresolved,
  useThreadSubscription,
  useHistoryVersionData,
  useUpdateRoomNotificationSettings,
  useOthersConnectionIdsSuspense,
  useStorageStatusSuspense,
  useAttachmentUrl,
  useAttachmentUrlSuspense,
  createRoomContext,
  _RoomProvider,
  _useBroadcastEvent,
  _useOthersListener,
  _useRoom,
  _useIsInsideRoom,
  _useAddReaction,
  _useMutation,
  _useCreateThread,
  _useDeleteThread,
  _useEditThreadMetadata,
  _useEventListener,
  _useMyPresence,
  _useOthersMapped,
  _useOthersMappedSuspense,
  _useThreads,
  _useThreadsSuspense,
  _useRoomNotificationSettings,
  _useRoomNotificationSettingsSuspense,
  _useHistoryVersions,
  _useHistoryVersionsSuspense,
  _useOther,
  _useOthers,
  _useOtherSuspense,
  _useOthersSuspense,
  _useStorage,
  _useStorageSuspense,
  _useSelf,
  _useSelfSuspense,
  _useStorageRoot,
  _useUpdateMyPresence
};
//# sourceMappingURL=chunk-A7GJNN4L.mjs.map